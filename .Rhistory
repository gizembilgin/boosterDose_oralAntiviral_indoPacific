for (t in 1:num_vax_types){ #iterating over vaccine types
this_vax = vax_type_list[t]
this_vax_history = vaccination_history_FINAL[vaccination_history_FINAL$vaccine_type == this_vax,]
# (1/3) recorded vax
#COMEBACK delay of J&J first does is 21 days, is this right?
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_1,]) >0){
dose_one <- as.numeric(this_vax_history$doses_delivered_this_date[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_1 & this_vax_history$dose==1])
}else { dose_one = rep(0,num_age_groups)}
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_2,]) >0){
dose_two <- as.numeric(this_vax_history$doses_delivered_this_date[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_2 & this_vax_history$dose==2])
}  else { dose_two = rep(0,num_age_groups)}
if (this_vax == "Johnson & Johnson") {dose_two = rep(0,num_age_groups)}
#NB: no booster dose yet!
VR_this_step <- cbind(dose_one,dose_two)
for (i in 1:num_age_groups){ # across age groups
increase_one = VR_this_step[i,1]
increase_two = VR_this_step[i,2]
for (j in 1:4){ #let's assume all SEIR vaccinated
#for (d in 1:D){ #COMEBACK could shorten code with dose  B = i + J*(t+(d-1)*T)
prop1 = prev_state[j,i]     / sum(prev_state[,i])       # prop unvax in SEIR
prop2 = prev_state[j,i+J*t] / sum(prev_state[,i+J*t]) # prop dose one
if (is.nan(prop1) == TRUE){prop1=0}
if (is.nan(prop2) == TRUE){prop2=0}
next_state[j,i]         = next_state[j,i] - increase_one*prop1
next_state[j,i+J*t]     = next_state[j,i+J*t] + increase_one*prop1-increase_two*prop2
next_state[j,i+J*(t+T)] = next_state[j,i+J*(t+T)] + increase_two * prop2
#}
}
}
}
# if (importation_toggle == "on"){
#   #Let's assume all importations from lowest vax class
#    imported_this_date = 3/7
#
#   rand_age = round(runif(1,min=1,max=num_age_groups))
#
#   if (length(imported_this_date) > 0 ){
#   x=2 #import to exposed or to infected?
#     if (next_state[1,rand_age] >= imported_this_date ){ #if someone who is Sunvax
#       next_state[1,rand_age] = next_state[1,rand_age] - imported_this_date
#       next_state[1+x*4,rand_age] = next_state[1+x*4,rand_age] + imported_this_date
#     } else if (next_state[2,rand_age] >= imported_this_date ){ #if someone who is Sv1
#       next_state[2,rand_age] = next_state[2,rand_age] - imported_this_date
#       next_state[2+x*4,rand_age] = next_state[2+x*4,rand_age] + imported_this_date
#     } else if (next_state[3,rand_age] >= imported_this_date ){ #if someone who is Sv2
#       next_state[3,rand_age] = next_state[3,rand_age] - imported_this_date
#       next_state[3+x*4,rand_age] = next_state[3+x*4,rand_age] + imported_this_date
#     }
#   }
#}
#next_state <- round(next_state,digits=0)
sum(next_state); sum(prev_state); sum(pop) # CHECK = confirmed equal
round(next_state)
round(prev_state)
t=1
vax_type_list
t=2
this_vax = vax_type_list[t]
this_vax_history = vaccination_history_FINAL[vaccination_history_FINAL$vaccine_type == this_vax,]
# (1/3) recorded vax
#COMEBACK delay of J&J first does is 21 days, is this right?
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_1,]) >0){
dose_one <- as.numeric(this_vax_history$doses_delivered_this_date[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_1 & this_vax_history$dose==1])
}else { dose_one = rep(0,num_age_groups)}
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_2,]) >0){
dose_two <- as.numeric(this_vax_history$doses_delivered_this_date[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_2 & this_vax_history$dose==2])
}  else { dose_two = rep(0,num_age_groups)}
if (this_vax == "Johnson & Johnson") {dose_two = rep(0,num_age_groups)}
VR_this_step <- cbind(dose_one,dose_two)
VR_this_step
View(vaccination_history_FINAL)
### WARNINGS
if (vax_strategy_vaccine_type == "Johnson & Johnson" & vax_dose_strategy > 1){stop('J&J can NOT be more than a 1 dose strategy')}
if (vax_strategy_start_date <= max(vaccination_history_TRUE$date)){
stop ('Your hypothetical vaccine campaign start date needs to be in the future!')
}
if (vax_strategy_start_date <= date_start){
stop ('Your hypothetical vaccine campaign start date needs to be after the start date (unless you want to do more coding)')
}
if (!(vax_strategy_vaccine_type %in% c("Moderna","Pfizer","AstraZeneca","Johnson & Johnson","Sinopharm","Sinovac"))){
stop('pick a valid vaccine type, or check your spelling!')
}
### IMPORTS
prioritisation_csv <- read.csv("1_inputs/prioritisation.csv",header=TRUE)
#####(1/?) Calculate the eligible population ###################################
eligible_pop = data.frame(pop_setting)
colnames(eligible_pop) = c('age_group','eligible_individuals')
eligible_pop$age_group = gsub('-',' to ',eligible_pop$age_group)
#make long by dose
workshop = data.frame()
for (i in 1:num_vax_doses){
this_dose = as.data.frame(eligible_pop) %>% mutate(dose = i)
workshop = rbind(workshop,this_dose)
}
eligible_pop= workshop
#remove already vaccinated individuals
existing_coverage = data.frame(eligible_pop$age_group,eligible_pop$dose,rep(0,num_age_groups*num_vax_doses))
colnames(existing_coverage) = c('age_group','dose','cov_to_date')
for (t in 1:num_vax_types){
for (d in 1:num_vax_doses){
#need to sum across vaccine_coverage (as this is vaccination_history_POP split across age groups)
existing_coverage$cov_to_date[existing_coverage$dose == d] =
existing_coverage$cov_to_date[existing_coverage$dose == d] + vaccine_coverage_end_history$cov[(J*(t+(d-1)*T) - J+1):(J*(t+(d-1)*T))]
}
}
#now remove vaccinated, and vaccine hesistant
unreachable = 1-vax_strategy_max_expected_cov
eligible_pop <- eligible_pop %>% left_join(existing_coverage) %>%
mutate(eligible_individuals = round(eligible_individuals *(1-(cov_to_date+unreachable)))) %>%
select(age_group,dose,eligible_individuals)
eligible_pop$eligible_individuals[eligible_pop$dose == 2] = eligible_pop$eligible_individuals[eligible_pop$dose == 1]
View(eligible_pop)
#####(2/?) Place priority # on age group by strategy ############################
if (vax_age_strategy %in% unique(prioritisation_csv$strategy)) {
elected_strategy = prioritisation_csv[prioritisation_csv$strategy == vax_age_strategy,c('age_group','priority')]
eligible_pop <- eligible_pop %>% left_join(elected_strategy)
} else if (vax_age_strategy == "manual_overwrite"){
eligible_pop <- eligible_pop %>%
mutate(priority= case_when(
age_group == '60 to 100' ~ 6,
age_group == '50 to 59' ~ 5,
age_group == '40 to 49' ~ 4,
age_group == '30 to 39' ~ 3,
age_group == '20 to 29' ~ 2,
age_group == '5 to 19' ~ 1,
age_group == '0 to 4' ~ 99
))
}
vax_age_strategy
VR_this_step
vaccination_history_FINAL = vaccination_history_FINAL %>% left_join(age_group_order)
#(iii/iv) Add hypothetical campaign (if 'on')
if (vax_strategy_plot == "on"){
vaccination_history_FINAL =
vax_strategy(vax_strategy_start_date        = vax_strategy_toggles$vax_strategy_start_date,
vax_strategy_num_doses         = vax_strategy_toggles$vax_strategy_num_doses,
vax_strategy_roll_out_speed    = vax_strategy_toggles$vax_strategy_roll_out_speed,
vax_age_strategy               = vax_strategy_toggles$vax_age_strategy,
vax_dose_strategy              = vax_strategy_toggles$vax_dose_strategy,
vax_strategy_vaccine_type      = vax_strategy_toggles$vax_strategy_vaccine_type,
vax_strategy_vaccine_interval  = vax_strategy_toggles$vax_strategy_vaccine_interval,
vax_strategy_max_expected_cov  = vax_strategy_toggles$vax_strategy_max_expected_cov
)
#recalculate!
num_vax_doses = D = length(unique(vaccination_history_FINAL$dose))  # dose 1, dose 2, COMEBACK no boosters yet in these settings
vax_type_list = sort(unique(vaccination_history_FINAL$vaccine_type))
num_vax_types = T = length(unique(vaccination_history_FINAL$vaccine_type))
num_vax_classes = num_vax_doses*num_vax_types + 1                 # + 1 for unvaccinated
num_total_classes = (num_disease_classes+1)*(num_age_groups*num_vax_classes) #+1 for incidence tracker
} else {
vaccination_history_FINAL = vaccination_history_TRUE
}
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_1,]) >0){
dose_one <- as.numeric(this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_1 & this_vax_history$dose==1])
}else { dose_one = rep(0,num_age_groups)}
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_2,]) >0){
dose_two <- as.numeric(this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_2 & this_vax_history$dose==2])
}  else { dose_two = rep(0,num_age_groups)}
if (this_vax == "Johnson & Johnson") {dose_two = rep(0,num_age_groups)}
as.numeric(this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_1 & this_vax_history$dose==1])
this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_1 & this_vax_history$dose==1,]
VR_this_step
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_1,]) >0){
dose_one <- this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_1 & this_vax_history$dose==1,]
}else { dose_one = rep(0,num_age_groups)}
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_2,]) >0){
dose_two <- this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_2 & this_vax_history$dose==2,]
}  else { dose_two = rep(0,num_age_groups)}
if (this_vax == "Johnson & Johnson") {dose_two$doses_delivered_this_date = 0}
VR_this_step = rbind(dose_one,dose_two)
VR_this_step
i=2
increase_one = VR_this_step$doses_delivered_this_date[VR_this_step$dose == 1 & VR_this_step$age_group == age_group_labels[i]]
increase_two = VR_this_step$doses_delivered_this_date[VR_this_step$dose == 2 & VR_this_step$age_group == age_group_labels[i]]
increase_one
increase_two
source("~/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(4)_time_step.R", echo=TRUE)
source("~/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(4)_time_step.R", echo=TRUE)
time_step = 1
num_time_steps = model_weeks *7
parameters = c(
suscept = suscept,
behaviour_mod=behaviour_mod,
uniform_mod = uniform_mod,
beta=beta,
NPI=NPI_inital,
contact_matrix=contact_matrix,
lota=lota,
gamma=gamma,
lambda=lambda,
delta=delta,
omega=omega,
rho=rho,
age_group_labels=age_group_labels,
vax_type_list=vax_type_list,
VE=VE,
# VE_onwards=VE_onwards,
num_age_groups=num_age_groups,
num_vax_types=num_vax_types,
num_vax_doses=num_vax_doses)
Reff_tracker = data.frame()
#Jfor (increments_number in 1:num_time_steps){
for (increments_number in 1:122){
if (increments_number == 1){
sol = as.data.frame(ode(y=state,times=(seq(0,time_step,by=1)),func=covidODE,parms=parameters))
sol_log <- sol
sol_log_unedited <- sol
Reff <- NA
Reff_tracker = rbind(Reff_tracker,Reff)
colnames(Reff_tracker) <- c('Reff')
} else{
date_now = date_start + increments_number*time_step
if (date_now <= max(NPI_estimates$date)){
NPI_this_step <- NPI_estimates$NPI[NPI_estimates$date == date_now]/100
parameters$NPI = NPI_this_step
} #i.e. assume after end date that NPI constant
if ((date_now - min(vaccine_coverage_delay))>= min(vaccination_history_FINAL$date)){
parameters$VE = VE_time_step(strain,date_now,'acquisition')
}
# selecting bottom row of solution which is time = 7 (one week)
state_working=tail.matrix(sol,1)
state_working=select(state_working,-time) #remove column with time
state_working=as.vector(state_working)
# lets reconstruct our matrix (easier to work with)
A=J*(T*D+1) # +1 is unvax
S = as.matrix(state_working[1:A])
E = as.matrix(state_working[(A+1):(2*A)])
I = as.matrix(state_working[(2*A+1):(3*A)])
R = as.matrix(state_working[(3*A+1):(4*A)])
Incid = as.matrix(state_working[(4*A+1):(5*A)])
prev_state <- as.data.frame(rbind(S,E,I,R))
row.names(prev_state) <- c("S","E","I","R")
next_state=prev_state # initialise next state
### VACCINATION
#COMEBACK append hypoth vaccine strategy
#if (vaccine_strategy_toggle == "on"){
#  if (date_now >= min(vaccine_strategy$date) & date_now <= max(vaccine_strategy$date)){
#
#  }
#}
for (t in 1:num_vax_types){ #iterating over vaccine types
this_vax = vax_type_list[t]
this_vax_history = vaccination_history_FINAL[vaccination_history_FINAL$vaccine_type == this_vax,]
# (1/3) recorded vax
#COMEBACK delay of J&J first does is 21 days, is this right?
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_1,]) >0){
dose_one <- this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_1 & this_vax_history$dose==1,]
}else { dose_one = rep(0,num_age_groups)}
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_2,]) >0){
dose_two <- this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_2 & this_vax_history$dose==2,]
}  else { dose_two = rep(0,num_age_groups)}
if (this_vax == "Johnson & Johnson") {dose_two$doses_delivered_this_date = 0}
VR_this_step = rbind(dose_one,dose_two)
for (i in 1:num_age_groups){ # across age groups
increase_one = VR_this_step$doses_delivered_this_date[VR_this_step$dose == 1 & VR_this_step$age_group == age_group_labels[i]]
increase_two = VR_this_step$doses_delivered_this_date[VR_this_step$dose == 2 & VR_this_step$age_group == age_group_labels[i]]
for (j in 1:4){ #let's assume all SEIR vaccinated
#for (d in 1:D){ #COMEBACK could shorten code with dose  B = i + J*(t+(d-1)*T)
prop1 = prev_state[j,i]     / sum(prev_state[,i])       # prop unvax in SEIR
prop2 = prev_state[j,i+J*t] / sum(prev_state[,i+J*t]) # prop dose one
if (is.nan(prop1) == TRUE){prop1=0}
if (is.nan(prop2) == TRUE){prop2=0}
next_state[j,i]         = next_state[j,i] - increase_one*prop1
next_state[j,i+J*t]     = next_state[j,i+J*t] + increase_one*prop1-increase_two*prop2
next_state[j,i+J*(t+T)] = next_state[j,i+J*(t+T)] + increase_two * prop2
#}
}
}
}
# if (importation_toggle == "on"){
#   #Let's assume all importations from lowest vax class
#    imported_this_date = 3/7
#
#   rand_age = round(runif(1,min=1,max=num_age_groups))
#
#   if (length(imported_this_date) > 0 ){
#   x=2 #import to exposed or to infected?
#     if (next_state[1,rand_age] >= imported_this_date ){ #if someone who is Sunvax
#       next_state[1,rand_age] = next_state[1,rand_age] - imported_this_date
#       next_state[1+x*4,rand_age] = next_state[1+x*4,rand_age] + imported_this_date
#     } else if (next_state[2,rand_age] >= imported_this_date ){ #if someone who is Sv1
#       next_state[2,rand_age] = next_state[2,rand_age] - imported_this_date
#       next_state[2+x*4,rand_age] = next_state[2+x*4,rand_age] + imported_this_date
#     } else if (next_state[3,rand_age] >= imported_this_date ){ #if someone who is Sv2
#       next_state[3,rand_age] = next_state[3,rand_age] - imported_this_date
#       next_state[3+x*4,rand_age] = next_state[3+x*4,rand_age] + imported_this_date
#     }
#   }
#}
#next_state <- round(next_state,digits=0)
sum(next_state); sum(prev_state); sum(pop) # CHECK = confirmed equal
next_state[next_state<0] <- 0
sum(next_state); sum(prev_state) # CHECK = NOT equal
# convert back into silly vector form for ODE solver
S_next=next_state[1,]
E_next=next_state[2,]
I_next=next_state[3,]
R_next=next_state[4,]
Reff <- Reff_time_step(parameters,next_state)
Reff_tracker = rbind(Reff_tracker,Reff)
next_state_FINAL=as.numeric(c(S_next,E_next,I_next,R_next,
Incidence_inital)) #setting Incid to repeated 0s
# next week!
sol <- as.data.frame(ode(y=next_state_FINAL,times=(seq(0,time_step,by=1)),func=covidODE,parms=parameters))
sol[,1]=sol[,1]+time_step*(increments_number-1) #make times correct
sol_log=head(sol_log,-1) #remove last entry from sol_log (overlap of two weekly runs)
sol_log <- rbind(sol_log,sol)
sol_log_unedited <- rbind(sol_log_unedited,sol)
}
}
date_now
sol = as.data.frame(ode(y=state,times=(seq(0,time_step,by=1)),func=covidODE,parms=parameters))
sol_log <- sol
sol_log_unedited <- sol
Reff <- NA
Reff_tracker = rbind(Reff_tracker,Reff)
colnames(Reff_tracker) <- c('Reff')
date_now = date_start + increments_number*time_step
if (date_now <= max(NPI_estimates$date)){
NPI_this_step <- NPI_estimates$NPI[NPI_estimates$date == date_now]/100
parameters$NPI = NPI_this_step
} #i.e. assume after end date that NPI constant
if ((date_now - min(vaccine_coverage_delay))>= min(vaccination_history_FINAL$date)){
parameters$VE = VE_time_step(strain,date_now,'acquisition')
}
# selecting bottom row of solution which is time = 7 (one week)
state_working=tail.matrix(sol,1)
state_working=select(state_working,-time) #remove column with time
state_working=as.vector(state_working)
# lets reconstruct our matrix (easier to work with)
A=J*(T*D+1) # +1 is unvax
S = as.matrix(state_working[1:A])
E = as.matrix(state_working[(A+1):(2*A)])
I = as.matrix(state_working[(2*A+1):(3*A)])
R = as.matrix(state_working[(3*A+1):(4*A)])
Incid = as.matrix(state_working[(4*A+1):(5*A)])
prev_state <- as.data.frame(rbind(S,E,I,R))
row.names(prev_state) <- c("S","E","I","R")
next_state=prev_state # initialise next state
for (t in 1:num_vax_types){ #iterating over vaccine types
this_vax = vax_type_list[t]
this_vax_history = vaccination_history_FINAL[vaccination_history_FINAL$vaccine_type == this_vax,]
# (1/3) recorded vax
#COMEBACK delay of J&J first does is 21 days, is this right?
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_1,]) >0){
dose_one <- this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_1 & this_vax_history$dose==1,]
}else { dose_one = rep(0,num_age_groups)}
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_2,]) >0){
dose_two <- this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_2 & this_vax_history$dose==2,]
}  else { dose_two = rep(0,num_age_groups)}
if (this_vax == "Johnson & Johnson") {dose_two$doses_delivered_this_date = 0}
VR_this_step = rbind(dose_one,dose_two)
for (i in 1:num_age_groups){ # across age groups
increase_one = VR_this_step$doses_delivered_this_date[VR_this_step$dose == 1 & VR_this_step$age_group == age_group_labels[i]]
increase_two = VR_this_step$doses_delivered_this_date[VR_this_step$dose == 2 & VR_this_step$age_group == age_group_labels[i]]
for (j in 1:4){ #let's assume all SEIR vaccinated
#for (d in 1:D){ #COMEBACK could shorten code with dose  B = i + J*(t+(d-1)*T)
prop1 = prev_state[j,i]     / sum(prev_state[,i])       # prop unvax in SEIR
prop2 = prev_state[j,i+J*t] / sum(prev_state[,i+J*t]) # prop dose one
if (is.nan(prop1) == TRUE){prop1=0}
if (is.nan(prop2) == TRUE){prop2=0}
next_state[j,i]         = next_state[j,i] - increase_one*prop1
next_state[j,i+J*t]     = next_state[j,i+J*t] + increase_one*prop1-increase_two*prop2
next_state[j,i+J*(t+T)] = next_state[j,i+J*(t+T)] + increase_two * prop2
#}
}
}
}
t
t=1
this_vax = vax_type_list[t]
this_vax_history = vaccination_history_FINAL[vaccination_history_FINAL$vaccine_type == this_vax,]
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_1,]) >0){
dose_one <- this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_1 & this_vax_history$dose==1,]
}else { dose_one = rep(0,num_age_groups)}
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_2,]) >0){
dose_two <- this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_2 & this_vax_history$dose==2,]
}  else { dose_two = rep(0,num_age_groups)}
if (this_vax == "Johnson & Johnson") {dose_two$doses_delivered_this_date = 0}
VR_this_step = rbind(dose_one,dose_two)
VR_this_step
dose_one
dose_two
if (nrow(this_vax_history[this_vax_history$date == as.Date(date_now) - vaccine_coverage_delay_2,]) >0){
dose_two <- this_vax_history[this_vax_history$date==as.Date(date_now) - vaccine_coverage_delay_2 & this_vax_history$dose==2,]
}  else { dose_two = crossing(date = date_now,
vaccine_type = this_vax,
vaccine_mode = 'dummy',
dose =2,
coverage_this_date = NA,
doses_delivered_this_date = 0,
age_group = age_group_labels)}
dose_two
VR_this_step = rbind(dose_one,dose_two)
VR_this_step
source("~/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(4)_time_step.R", echo=TRUE)
source("~/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(4)_time_step.R", echo=TRUE)
source("~/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", echo=TRUE)
i=1
### (2) Queue strategies to run ##################################################################################################
queue = list()
#COMEBACK - after the baseline and no intervention, could the remaining be in a csv?
# queue[[1]]
vax_strategy_description = 'no intervention'
vax_strategy_plot = "off"
queue[[1]] = list(vax_strategy_description,vax_strategy_plot)
# queue[[2]]
vax_strategy_description = 'baseline - current country strategy'
vax_strategy_plot = "on"
vax_strategy_toggles =
list(vax_strategy_start_date                  = as.Date('2022-04-20'),
vax_strategy_num_doses         = as.integer(1000000),
vax_strategy_roll_out_speed    = 500000 ,               # doses delivered per day
vax_age_strategy               = "oldest",            # options: "oldest", "youngest","50_down","uniform", OTHER?
vax_dose_strategy              = 2,                    # options: 1,2
vax_strategy_vaccine_type      = "Pfizer" ,            # options: "Moderna","Pfizer","AstraZeneca","Johnson & Johnson","Sinopharm","Sinovac"
vax_strategy_vaccine_interval  = 7*3 ,                 # (days) interval between first and second dose
vax_strategy_max_expected_cov  = 0.8                   # value between 0-1 (equivalent to %) of age group willing to be vaccinated
)
queue[[2]] = list(vax_strategy_description,vax_strategy_toggles,vax_strategy_plot)
# queue[[3]]
vax_strategy_description = 'go 1'
vax_strategy_toggles =
list(vax_strategy_start_date                  = as.Date('2022-04-20'),
vax_strategy_num_doses         = as.integer(1000000),
vax_strategy_roll_out_speed    = 500000 ,               # doses delivered per day
vax_age_strategy               = "oldest",            # options: "oldest", "youngest","50_down","uniform", OTHER?
vax_dose_strategy              = 1,                    # options: 1,2
vax_strategy_vaccine_type      = "Johnson & Johnson" ,            # options: "Moderna","Pfizer","AstraZeneca","Johnson & Johnson","Sinopharm","Sinovac"
vax_strategy_vaccine_interval  = 7*3 ,                 # (days) interval between first and second dose
vax_strategy_max_expected_cov  = 0.8                   # value between 0-1 (equivalent to %) of age group willing to be vaccinated
)
queue[[3]] = list(vax_strategy_description,vax_strategy_toggles)
i=1
commands = queue[[i]]
commands
# queue[[1]]
queue[[1]] = list(vax_strategy_description = "no intervnetion",
vax_strategy_plot = "off")
commands = queue[[i]]
commands
names(commands)
('vax_strategy_plot' %in% names(commands))
if ('vax_strategy_plot' %in% names(commands)){
vax_strategy_plot = commands$vax_strategy_plot
}
source("~/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(plot)_vax_strategies.R", echo=TRUE)
source("~/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(plot)_vax_strategies.R", echo=TRUE)
severe_outcome_tracker
source("~/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(plot)_vax_strategies.R", echo=TRUE)
setting
queu
queue
View(severe_outcome_tracker)
plot_list = list()
for (i in 1:length(unique(severe_outcome_tracker$outcome))){
outcome = unique(severe_outcome_tracker$outcome)[i]
plot_list [[i]] <- ggplot(data=severe_outcome_tracker[severe_outcome_tracker$outcome==outcome,]) +
geom_point(aes(x=date,y=proj_cum,color=as.factor(label))) +
labs(title=paste("projected",outcome,"by vax strategy",sep=""))
}
gridExtra::grid.arrange(grobs=plot_list)
install.packages(ggpubr)
install.packages('ggpubr'')
install.packages('ggpubr')
ggarrange(plot_list)
require(ggpubr)
ggarrange(plot_list)
plot_list
paste((for i in 1:length(plot_list){plot_list[i]})
paste(((for i in 1:length(plot_list){plot_list[i]}))
paste(((for i in 1:length(plot_list)){plot_list[i]}))
paste(((for i in 1:length(plot_list)){plot_list[i]})
ggarrange(plot_list[1],plot_list[2],plot_list[3])
ggarrange(plot_list[[1]],plot_list[[2]],plot_list[[3]]
)
ggarrange(plot_list[[1]],plot_list[[2]],plot_list[[3]],
common.legen = TRUE,
legen="bottom"
)
ggarrange(plot_list[[1]],plot_list[[2]],plot_list[[3]],
common.legen = TRUE,
legend="bottom"
)
ggarrange(plot_list[[1]],plot_list[[2]],plot_list[[3]],
common.legend = TRUE,
legend="bottom"
)
ggarrange(plot_list[[1]],plot_list[[2]],plot_list[[3]],plot_list[[4]],plot_list[[5]],
common.legend = TRUE,
legend="bottom"
)
plot_list = list()
for (i in 1:length(unique(severe_outcome_tracker$outcome))){
outcome = unique(severe_outcome_tracker$outcome)[i]
plot_list [[i]] <- ggplot(data=severe_outcome_tracker[severe_outcome_tracker$outcome==outcome,]) +
geom_point(aes(x=date,y=proj_cum,color=as.factor(label))) +
labs(title=paste("projected ",outcome,"by vax strategy",sep=""))
}
gridExtra::grid.arrange(grobs=plot_list)
require(ggpubr)
ggarrange(plot_list[[1]],plot_list[[2]],plot_list[[3]],plot_list[[4]],plot_list[[5]],
common.legend = TRUE,
legend="bottom"
)
setting
setting
source("~/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(plot)_vax_strategies.R", echo=TRUE)
ggarrange(plot_list[[1]],plot_list[[2]],plot_list[[3]],plot_list[[4]],plot_list[[5]],
common.legend = TRUE,
legend="bottom"
)
