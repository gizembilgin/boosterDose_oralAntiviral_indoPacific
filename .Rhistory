state_working = tail.matrix(sol, 1)
state_working = select(state_working, -time) #remove column with time
state_working = as.vector(state_working)
A = RISK * J * (T * D + 1) # +1 is unvax
S = as.matrix(state_working[1:A])
E = as.matrix(state_working[(A + 1):(2 * A)])
I = as.matrix(state_working[(2 * A + 1):(3 * A)])
R = as.matrix(state_working[(3 * A + 1):(4 * A)])
Incid = as.matrix(state_working[(4 * A + 1):(5 * A)])
prev_state = data.frame()
class_list = list(S, E, I, R)
class_name_list = c('S', 'E', 'I', 'R')
for (i in 1:num_disease_classes) {
workshop = data.frame(pop = class_list[[i]])
row.names(workshop) = NULL
workshop = workshop %>% mutate(class =  class_name_list[i])
workshop$temp = rep(seq(1, (num_age_groups * num_vax_classes)), RISK)
workshop$age_group = rep(age_group_labels, num_vax_classes * RISK)
workshop$dose = 0
workshop$vaccine_type = "unvaccinated"
for (d in 1:num_vax_doses) {
workshop$dose[workshop$temp %in% c((T * (d - 1) + 1) * J + 1):((T * d +
1) * J)] = d
for (t in 1:num_vax_types) {
workshop$vaccine_type[workshop$temp %in% c((((t - 1) + (d - 1) * T + 1) *
J + 1):(((t - 1) + (d - 1) * T + 2) * J))] = vax_type_list[t]
}
}
workshop$risk_group = 'general_public'
if (RISK > 1) {
workshop$risk_group[(num_age_groups * num_vax_classes + 1):(num_age_groups *
num_vax_classes * 2)] = risk_group_name
}
prev_state = rbind(prev_state, workshop)
}
prev_state$pop  = as.numeric(prev_state$pop)
if (round(sum(prev_state$pop)) != sum(pop)) {
stop('prev state not equal to pop size! (~line 105 in time step)')
}
next_state = prev_state # initialise next state
### Include today's primary doses
for (this_risk_group in unique(vaccination_history_FINAL$risk_group)){
for (this_vax in unique(vaccination_history_FINAL$vaccine_type[vaccination_history_FINAL$schedule == "primary"])){  #iterating over vaccine types
this_vax_history = vaccination_history_FINAL %>%
filter(schedule == "primary" &
doses_delivered_this_date >0 &
vaccine_type == this_vax &
risk_group == this_risk_group &
(dose == 1 & date == as.Date(date_now) - vaxCovDelay$delay[vaxCovDelay$dose == 1]|
dose == 2 & date == as.Date(date_now) - vaxCovDelay$delay[vaxCovDelay$dose == 2]))
if(nrow(this_vax_history)>0){
for (this_age_group in unique(this_vax_history$age_group)){
increase = rep(0,D_primary)
for (d in unique(this_vax_history$dose[this_vax_history$age_group == this_age_group])){
increase[d] = this_vax_history$doses_delivered_this_date[this_vax_history$dose == d & this_vax_history$age_group == this_age_group]
}
for (this_class in class_name_list){ #ASSUMPTION: all SEIR vaccinated
prop = rep(0,num_vax_doses) #prop in S,E,I or R in vaccine groups
for (d in 0:D_primary){
if (d==0){
prop[d+1] = prev_state$pop[prev_state$class == this_class & prev_state$risk_group == this_risk_group & prev_state$vaccine_type == "unvaccinated" & prev_state$age_group == this_age_group]/
sum(prev_state$pop[prev_state$vaccine_type == "unvaccinated" & prev_state$risk_group == this_risk_group & prev_state$age_group == this_age_group])
} else{
prop[d+1] = prev_state$pop[prev_state$class == this_class & prev_state$risk_group == this_risk_group & prev_state$vaccine_type == this_vax &  prev_state$dose == d & prev_state$age_group == this_age_group]/
sum(prev_state$pop[prev_state$risk_group == this_risk_group & prev_state$vaccine_type == this_vax & prev_state$dose == d & prev_state$age_group == this_age_group])
}
if (is.nan(prop[d+1]) == TRUE){prop[d+1]=0}
}
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == "unvaccinated" & next_state$age_group == this_age_group] =
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == "unvaccinated" & next_state$age_group == this_age_group] - increase[1]* prop[1]
for (d in 1:(D_primary-1)){
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == d & next_state$age_group == this_age_group] =
next_state$pop[ next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == d & next_state$age_group == this_age_group] + increase[d]*prop[d]-increase[d+1]*prop[d+1]
}
for (d in D_primary){
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == D_primary & next_state$age_group == this_age_group] =
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == D_primary & next_state$age_group == this_age_group] + increase[D_primary] * prop[D_primary]
}
}
}
}
}
}
### Include today's booster doses
todays_boosters = vaccination_history_FINAL %>% filter(schedule == "booster" & doses_delivered_this_date >0 & date == as.Date(date_now) - vaxCovDelay$delay[vaxCovDelay$dose == 2])
if (nrow(todays_boosters)>0){
for (this_risk_group in unique(todays_boosters$risk_group)){
for (this_vax in unique(todays_boosters$vaccine_type)){
for (this_dose in unique(todays_boosters$dose)){
for (from_vax in unique(todays_boosters$FROM_vaccine_type[todays_boosters$vaccine_type == this_vax & todays_boosters$dose == this_dose])){  #iterating over vaccine types FROM
for (from_dose in unique(todays_boosters$FROM_dose[todays_boosters$vaccine_type == this_vax & todays_boosters$dose == this_dose])){
this_vax_history = todays_boosters %>%
filter(FROM_vaccine_type == from_vax &
FROM_dose == from_dose &
risk_group == this_risk_group &
vaccine_type == this_vax &
dose == this_dose &
date == as.Date(date_now) - vaxCovDelay$delay[vaxCovDelay$dose == this_dose])
if (this_dose == 8){this_dose = booster_dose_number}
if (nrow(this_vax_history)>0){
for (this_age_group in unique(this_vax_history$age_group)){ # across age groups
increase = this_vax_history$doses_delivered_this_date[this_vax_history$age_group == this_age_group]
for (this_class in class_name_list){ #let's assume all SEIR vaccinated
prop = prev_state$pop[prev_state$class == this_class & prev_state$risk_group == this_risk_group & prev_state$vaccine_type == from_vax &  prev_state$dose == from_dose & prev_state$age_group == this_age_group]/
sum(prev_state$pop[prev_state$risk_group == this_risk_group & prev_state$vaccine_type == from_vax & prev_state$dose == from_dose & prev_state$age_group == this_age_group])
if (is.nan(prop) == TRUE){prop=0}
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == this_dose & next_state$age_group == this_age_group] =
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == this_dose & next_state$age_group == this_age_group] + increase * prop
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == from_vax & next_state$dose == from_dose & next_state$age_group == this_age_group] =
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == from_vax & next_state$dose == from_dose & next_state$age_group == this_age_group] - increase * prop
}
}
}
}
}
}
}
}
rm(from_vax,from_dose,this_vax_history, this_risk_group, this_vax, this_age_group, increase, this_class, prop)
}
if (fitting == "on" & date_now == as.Date('2021-11-14')){next_state_FIT = next_state} #savings to compare against known point of seroprevalence
if (date_now %in% covid19_waves$date){
if (date_now == min(covid19_waves$date[covid19_waves$strain == "delta"])){
strain_now = 'delta'
} else if (date_now == min(covid19_waves$date[covid19_waves$strain == "omicron"])){
strain_now = 'omicron'
#parameters$lambda = 1/2.22 #COMEBACK - hard coded :(
#parameters$delta = 1/9.87
}
prev_beta = parameters$beta
parameters$beta = rep(beta_fitted_values$beta_optimised[beta_fitted_values$strain == strain_now],num_age_groups)*
fitting_beta[which(covid19_waves$date == date_now)]
this_beta = parameters$beta
seed.Infected = seed*AverageSymptomaticPeriod/(AverageSymptomaticPeriod+AverageLatentPeriod)
seed.Exposed  = seed*AverageLatentPeriod/(AverageSymptomaticPeriod+AverageLatentPeriod)
#ASSUMPTION: uniform across age groups
seed.Infected = round(seed.Infected * pop/sum(pop))
seed.Exposed = round(seed.Exposed * pop/sum(pop))
for (i in 1:num_age_groups){ # across age groups
infect = seed.Infected[i]
expose = seed.Exposed[i]
infect = round(infect * next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] /sum(next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]]))
expose = round(expose * next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] /sum(next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]]))
next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] - infect - expose
next_state$pop[next_state$class == 'I'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'I'  & next_state$age_group == age_group_labels[i]] + infect
next_state$pop[next_state$class == 'E'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'E'  & next_state$age_group == age_group_labels[i]] + expose
}
}
#shift from delta to omicron parameters
if (date_now %in% omicron_shift$date){
parameters$lambda = 1/2.22*omicron_shift$percentage[omicron_shift$date == date_now] +
1/3.71 * (1-omicron_shift$percentage[omicron_shift$date == date_now])
parameters$delta = 1/9.87*omicron_shift$percentage[omicron_shift$date == date_now] +
1/10.9 * (1-omicron_shift$percentage[omicron_shift$date == date_now])
parameters$beta = this_beta*omicron_shift$percentage[omicron_shift$date == date_now] + prev_beta * (1-omicron_shift$percentage[omicron_shift$date == date_now])
}
# if (fitting == "off"){
#   if (date_now>=seed_date){
#     parameters$VE$VE = parameters$VE$VE * 0.9
#     parameters$rho = parameters$rho * 0.9
#   }
# }
if (round(sum(next_state$pop)) != round(sum(prev_state$pop))) {
stop('pop not retained between next_state and prev_state!')
}
if (round(sum(next_state$pop)) != sum(pop)) {
stop('pop in next_state not equal to setting population')
}
if (nrow(next_state[round(next_state$pop) < 0, ]) > 0) {
if (date_now > max(vaccination_history_TRUE$date + max(vaxCovDelay$delay))) {
stop('(4)_time_step line ~290')
} else{
if (nrow(next_state[round(next_state$pop) < -100, ]) > 0) {#Note: some negatives expected here due to recreation of vaccination_history
warning('(4)_time_step line ~290, possibility to do with vaccination_history configuration')
}
}
}
# convert back into untidy long vector form for ODE solver
workshop = next_state
workshop$class = factor(workshop$class, levels = disease_class_list)
workshop$risk_group = factor(workshop$risk_group, levels = risk_group_labels)
workshop$vaccine_type = factor(workshop$vaccine_type, levels = vax_type_list)
workshop$age_group = factor(workshop$age_group, levels = age_group_labels)
next_state = workshop %>% arrange(class, risk_group, dose, vaccine_type, age_group)
S_next = next_state$pop[next_state$class == 'S']
E_next = next_state$pop[next_state$class == 'E']
I_next = next_state$pop[next_state$class == 'I']
R_next = next_state$pop[next_state$class == 'R']
next_state_FINAL=as.numeric(c(S_next,E_next,I_next,R_next,
Incidence_inital,Exposed_incidence_inital)) #setting Incid to repeated 0s
rm(S_next,E_next,I_next,R_next)
}
# next time_step!
sol <- as.data.frame(ode(y=next_state_FINAL,times=(seq(0,time_step,by=1)),func=covidODE,parms=parameters))
sol[,1]=sol[,1]+time_step*(increments_number-1) #make times correct
if (increments_number>1){ sol_log=head(sol_log,-1) }#remove last entry from sol_log (overlap of runs)
sol_log <- rbind(sol_log,sol)
sol_log_unedited <- rbind(sol_log_unedited,sol)
### INCIDENCE CALCULATIONS
J = num_age_groups
T = num_vax_types
D = num_vax_doses
RISK = num_risk_groups
A = RISK * J * (T * D + 1) # +1 is unvax
incidence_log_unedited <- sol_log_unedited[, c(1,(A*num_disease_classes+2):(A*(num_disease_classes+1)+1))]
incidence_log_unedited <- incidence_log_unedited %>% filter (time %% time_step == 0, rowSums(incidence_log_unedited) != time)
incidence_log_unedited <- distinct(round(incidence_log_unedited,digits=2))
incidence_log_unedited$date <- date_start + incidence_log_unedited$time
incidence_log_unedited$daily_cases  <- rowSums(incidence_log_unedited[,2:(A+1)])
incidence_log <- incidence_log_unedited %>% select(date,daily_cases)
if (! fitting == "on"){incidence_log = rbind(fitted_incidence_log,incidence_log)}
incidence_log = incidence_log %>%
mutate(rolling_average = (daily_cases + lag(daily_cases) + lag(daily_cases,n=2)+lag(daily_cases,n=3)
+lag(daily_cases,n=4)+lag(daily_cases,n=5)+lag(daily_cases,n=6))/7,
rolling_average_percentage = 100*rolling_average/sum(pop),
cumulative_incidence = cumsum(daily_cases),
cumulative_incidence_percentage = 100*cumsum(daily_cases)/sum(pop))
if (fitting_details == "on"){
Reff <- Reff_time_step(parameters, next_state)
Reff_tracker = rbind(Reff_tracker, Reff)
rho_tracker_dataframe = rbind(rho_tracker_dataframe,parameters$rho)
workshop = parameters$VE
workshop = workshop[workshop$VE > 0, ] %>% mutate(immunity = paste(vaccine_type, dose))
if (nrow(workshop) > 0) {
workshop = aggregate(workshop$VE,
by = list(category = workshop$immunity),
FUN = mean)
colnames(workshop) = c('dose', 'VE')
workshop$date = date_now
VE_tracker_dataframe = rbind(VE_tracker_dataframe, workshop)
}
}
}
} ### END INCREMENT (#incidence log moved within loop to allow rho_time_step to access)
parameters$beta
parameters$beta1
parameters$beta
parameters$beta1
fitting_beta
colnames(parameters)
parameters
parameters$beta1
parameters$beta1
prev_beta = c(parameters$beta1,parameters$beta2)
prev_beta
prev_beta = rep(parameters$beta1,J)
prev_beta
if (date_now %in% covid19_waves$date){
if (date_now == min(covid19_waves$date[covid19_waves$strain == "delta"])){
strain_now = 'delta'
} else if (date_now == min(covid19_waves$date[covid19_waves$strain == "omicron"])){
strain_now = 'omicron'
#parameters$lambda = 1/2.22 #COMEBACK - hard coded :(
#parameters$delta = 1/9.87
}
prev_beta = rep(parameters$beta1,J)
parameters$beta = rep(beta_fitted_values$beta_optimised[beta_fitted_values$strain == strain_now],num_age_groups)*
fitting_beta[which(covid19_waves$date == date_now)]
this_beta = parameters$beta
seed.Infected = seed*AverageSymptomaticPeriod/(AverageSymptomaticPeriod+AverageLatentPeriod)
seed.Exposed  = seed*AverageLatentPeriod/(AverageSymptomaticPeriod+AverageLatentPeriod)
#ASSUMPTION: uniform across age groups
seed.Infected = round(seed.Infected * pop/sum(pop))
seed.Exposed = round(seed.Exposed * pop/sum(pop))
for (i in 1:num_age_groups){ # across age groups
infect = seed.Infected[i]
expose = seed.Exposed[i]
infect = round(infect * next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] /sum(next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]]))
expose = round(expose * next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] /sum(next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]]))
next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] - infect - expose
next_state$pop[next_state$class == 'I'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'I'  & next_state$age_group == age_group_labels[i]] + infect
next_state$pop[next_state$class == 'E'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'E'  & next_state$age_group == age_group_labels[i]] + expose
}
}
parameters$beta
prev_beta
parameters$beta = rep(beta_fitted_values$beta_optimised[beta_fitted_values$strain == strain_now],num_age_groups)*
fitting_beta[which(covid19_waves$date == date_now)]
parameters$beta
rep(beta_fitted_values$beta_optimised[beta_fitted_values$strain == strain_now],num_age_groups)
fitting_beta[which(covid19_waves$date == date_now)]
date_now
date_now %in% covid19_waves$date
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(4)_time_step.R", echo=TRUE)
source(paste(getwd(),"/CommandDeck.R",sep=""),local=TRUE)
date_now
#FIT SECOND WAVE_______________________________
if (exists("fitting_beta")){rm(fitting_beta)}
if (exists("under_reporting_est")){rm(under_reporting_est)}
if (exists("covid19_waves")){rm(covid19_waves)}
fit_daily_reported <- function(par){
load(file = paste('1_inputs/fit/first_wave_fit',this_setting,'.Rdata',sep=''))
strain_inital = strain_now = 'WT'
model_weeks =as.numeric((fit_cutoff_dates[2]-date_start)/7)
covid19_waves = data.frame(date = c(as.Date('2021-06-09')+first_wave_fit$par[1],
as.Date('2021-10-15')+par[1]),
strain = c('delta','omicron'))
under_reporting_est = par[2]
fitting_beta= c(first_wave_fit$par[3],par[3])
source(paste(getwd(),"/CommandDeck.R",sep=""),local=TRUE)
workshop = case_history %>%
filter(date > fit_cutoff_dates[1]) %>% #fit only after first wave
select(date,rolling_average) %>%
mutate(#under_reporting_est = coeff1 + coeff2*as.numeric(date - date_start), #linear
rolling_average = rolling_average * under_reporting_est) %>%
rename(adjusted_reported = rolling_average) %>%
left_join(incidence_log, by = "date") %>%
mutate(fit_statistic = abs(rolling_average - adjusted_reported)^2)
fit_statistic = sum(workshop$fit_statistic,na.rm=TRUE)
return(fit_statistic)
}
system.time({second_wave_fit = optim(c(0,40,1),
fit_daily_reported,
method = "Nelder-Mead")})
336310.29 /60/60
second_wave_fit
par
second_wave_fit$par
first_wave_fit
rm(par)
par
fitting_beta
under_reporting_est
covid19_waves
second_wave_fit
par
load(file = paste('1_inputs/fit/first_wave_fit',this_setting,'.Rdata',sep=''))
par
first_wave_fit
fit_daily_reported <- function(par){
load(file = paste('1_inputs/fit/first_wave_fit',this_setting,'.Rdata',sep=''))
strain_inital = strain_now = 'WT'
model_weeks =as.numeric((fit_cutoff_dates[2]-date_start)/7)
covid19_waves = data.frame(date = c(as.Date('2021-06-09')+first_wave_fit$par[1],
as.Date('2021-10-15')+par[1]),
strain = c('delta','omicron'))
under_reporting_est = par[2]
fitting_beta= c(first_wave_fit$par[3],par[3])
source(paste(getwd(),"/CommandDeck.R",sep=""),local=TRUE)
workshop = case_history %>%
filter(date > fit_cutoff_dates[1]) %>% #fit only after first wave
select(date,rolling_average) %>%
mutate(#under_reporting_est = coeff1 + coeff2*as.numeric(date - date_start), #linear
rolling_average = rolling_average * under_reporting_est) %>%
rename(adjusted_reported = rolling_average) %>%
left_join(incidence_log, by = "date") %>%
mutate(fit_statistic = abs(rolling_average - adjusted_reported)^2)
fit_statistic = sum(workshop$fit_statistic,na.rm=TRUE)
return(fit_statistic)
}
system.time({second_wave_fit = optim(c(0,40,1),
fit_daily_reported,
method = "Nelder-Mead")})
279677.81 /60/60
second_wave_fit
warnings()
#       (1/4) Setup
####################################################################
#load libraries
library(readr)
library(deSolve)
library(rvest)
library(ggplot2)
library(gridExtra)
library(ggpubr)
library(tidyverse)
covid19_waves
first_wave_fit
strain_inital = strain_now = 'WT'
#look at current fit
load(file = paste('1_inputs/fit/first_wave_fit',this_setting,'.Rdata',sep=''))
date_start = as.Date('2021-04-30')
strain_inital = strain_now = 'WT'
covid19_waves = data.frame(date =
c(as.Date('2021-06-09')+first_wave_fit$par[1],
as.Date('2021-11-01'),
as.Date('2022-04-01')),
strain = c('delta','omicron','omicron'))
model_weeks = as.numeric((Sys.Date()+1-date_start)/7)
under_reporting_est = first_wave_fit$par[2]
fitting_beta= c(first_wave_fit$par[3],
1,
1)
source(paste(getwd(),"/CommandDeck.R",sep=""),local=TRUE)
workshop = case_history %>%
select(date,rolling_average) %>%
mutate(#under_reporting_est = coeff1 + coeff2*as.numeric(date - date_start), #linear
rolling_average = rolling_average * under_reporting_est) %>%
rename(adjusted_reported = rolling_average) %>%
left_join(incidence_log, by = "date") %>%
mutate(fit_statistic = abs(rolling_average - adjusted_reported)^2)
fit_statistic = sum(workshop$fit_statistic,na.rm=TRUE)
to_plot = workshop %>% filter(date>date_start & date<=(date_start+model_weeks*7))
ggplot() +
geom_line(data=to_plot,aes(x=date,y=rolling_average),na.rm=TRUE) +
geom_point(data=to_plot,aes(x=date,y=adjusted_reported)) +
plot_standard
first_wave_fit
date_start
covid19_waves
fitting_beta
under_reporting_est
par
par = first_wave_fit$par
par
strain_inital = strain_now = 'WT'
model_weeks = as.numeric((fit_cutoff_dates[1]-date_start-1)/7)
covid19_waves = data.frame(date = as.Date('2021-06-09')+round(par[1]),
strain = 'delta')
under_reporting_est = par[2]
fitting_beta= par[3]
source(paste(getwd(),"/CommandDeck.R",sep=""),local=TRUE)
workshop = case_history %>%
select(date,rolling_average) %>%
mutate(#under_reporting_est = coeff1 + coeff2*as.numeric(date - date_start), #linear
rolling_average = rolling_average * under_reporting_est) %>%
rename(adjusted_reported = rolling_average) %>%
left_join(incidence_log, by = "date") %>%
mutate(fit_statistic = abs(rolling_average - adjusted_reported)^2)
to_plot = workshop %>% filter(date>date_start & date<=(date_start+model_weeks*7))
ggplot() +
geom_line(data=to_plot,aes(x=date,y=rolling_average),na.rm=TRUE) +
geom_point(data=to_plot,aes(x=date,y=adjusted_reported)) +
plot_standard
date_start
strain_inital
covid19_waves
under_reporting_est
save_plot = to_plot
save_incidence_log = incidence_log
load(file = paste('1_inputs/fit/first_wave_fit',this_setting,'.Rdata',sep=''))
date_start = as.Date('2021-04-30')
strain_inital = strain_now = 'WT'
covid19_waves = data.frame(date =
c(as.Date('2021-06-09')+first_wave_fit$par[1],
as.Date('2021-11-01'),
as.Date('2022-04-01')),
strain = c('delta','omicron','omicron'))
model_weeks = as.numeric((Sys.Date()+1-date_start)/7)
under_reporting_est = first_wave_fit$par[2]
fitting_beta= c(first_wave_fit$par[3],
1,
1)
source(paste(getwd(),"/CommandDeck.R",sep=""),local=TRUE)
workshop = case_history %>%
select(date,rolling_average) %>%
mutate(#under_reporting_est = coeff1 + coeff2*as.numeric(date - date_start), #linear
rolling_average = rolling_average * under_reporting_est) %>%
rename(adjusted_reported = rolling_average) %>%
left_join(incidence_log, by = "date") %>%
mutate(fit_statistic = abs(rolling_average - adjusted_reported)^2)
to_plot = workshop %>% filter(date>date_start & date<=(date_start+model_weeks*7))
ggplot() +
geom_line(data=to_plot,aes(x=date,y=rolling_average),na.rm=TRUE) +
geom_point(data=to_plot,aes(x=date,y=adjusted_reported)) +
plot_standard
covid19_waves
under_reporting_est
fitting
num_time_steps
model_weeks *7
fitting_beta
date_now %in% covid19_waves$date
omicron_shift
nrow(covid19_waves[covid19_waves$date<date_now & covid19_waves$strain == "omicron",])>0
nrow(covid19_waves[covid19_waves$date<date_now & covid19_waves$strain == "omicron",])
date_now = date_start
nrow(covid19_waves[covid19_waves$date<date_now & covid19_waves$strain == "omicron",])
date_start
to_plot = workshop %>% filter(date>date_start & date<=(date_start+model_weeks*7))
ggplot() +
geom_line(data=to_plot,aes(x=date,y=rolling_average),na.rm=TRUE) +
geom_point(data=to_plot,aes(x=date,y=adjusted_reported)) +
plot_standard
date_start
first_wave_fit$par
date_start
strain_inital
strain_now
covid19_waves
as.Date('2021-06-09')+first_wave_fit$par[1]
first_wave_fit
first_wave_fit$par[1]
as.Date('2021-06-09')+round(first_wave_fit$par[1])
load(file = paste('1_inputs/fit/first_wave_fit',this_setting,'.Rdata',sep=''))
date_start = as.Date('2021-04-30')
strain_inital = strain_now = 'WT'
covid19_waves = data.frame(date =
c(as.Date('2021-06-09')+round(first_wave_fit$par[1]),
as.Date('2021-11-01'),
as.Date('2022-04-01')),
strain = c('delta','omicron','omicron'))
model_weeks = as.numeric((Sys.Date()+1-date_start)/7)
under_reporting_est = first_wave_fit$par[2]
fitting_beta= c(first_wave_fit$par[3],
1,
1)
source(paste(getwd(),"/CommandDeck.R",sep=""),local=TRUE)
workshop = case_history %>%
select(date,rolling_average) %>%
mutate(#under_reporting_est = coeff1 + coeff2*as.numeric(date - date_start), #linear
rolling_average = rolling_average * under_reporting_est) %>%
rename(adjusted_reported = rolling_average) %>%
left_join(incidence_log, by = "date") %>%
mutate(fit_statistic = abs(rolling_average - adjusted_reported)^2)
fit_statistic = sum(workshop$fit_statistic,na.rm=TRUE)
to_plot = workshop %>% filter(date>date_start & date<=(date_start+model_weeks*7))
ggplot() +
geom_line(data=to_plot,aes(x=date,y=rolling_average),na.rm=TRUE) +
geom_point(data=to_plot,aes(x=date,y=adjusted_reported)) +
plot_standard
covid19_waves
