load(file = '1_inputs/fitted_results_SA_2022.Rdata')
}
}
if (risk_group_toggle == "off"){
this_risk_group_scenario = "no risk group"
} else {
this_risk_group_scenario = risk_group_name
}
parameters = fitted_results[[1]] %>%
filter(fitted_risk_group_scenario == this_risk_group_scenario)
fitted_next_state = fitted_results[[2]] %>%
filter(fitted_risk_group_scenario == this_risk_group_scenario)
fitted_incidence_log_tidy = fitted_results[[3]] %>%
filter(fitted_risk_group_scenario == this_risk_group_scenario)
fitted_incidence_log = fitted_results[[4]] %>%
filter(fitted_risk_group_scenario == this_risk_group_scenario)
rm(fitted_results)
fitted_incidence_log_tidy = fitted_incidence_log_tidy %>% filter(date <= date_start)
fitted_incidence_log = fitted_incidence_log %>% filter(date <= date_start)
if (risk_group_toggle == "on"){
if ((is.na(risk_group_prioritisation_to_date) == FALSE) ){
stop('no fitted result avaliable for this risk group characteristic')
}
}
} else if('vax_hesistancy_risk_group' %in% names(sensitivity_analysis_toggles)){
if (! risk_group_name == 'pregnant_women'){stop('havent configured vax hesistance sensitivity analysis for another risk group')}
load(file = '1_inputs/SA_vaxHest_fitted_results.Rdata')
parameters = SA_vaxHest_fitted_results[[1]] %>% filter(country == setting)
fitted_next_state = SA_vaxHest_fitted_results[[2]]  %>% filter(country == setting)
fitted_incidence_log_tidy = SA_vaxHest_fitted_results[[3]]  %>% filter(country == setting)
fitted_incidence_log = SA_vaxHest_fitted_results[[4]]  %>% filter(country == setting)
rm(SA_vaxHest_fitted_results)
fitted_incidence_log_tidy = fitted_incidence_log_tidy %>% filter(date <= date_start) # CHECKED last of fitted log = first of new log
fitted_incidence_log = fitted_incidence_log %>% filter(date <= date_start)
}
if ( debug == "on" | fitting_details == "on"){
Reff_tracker = data.frame()
rho_tracker_dataframe = data.frame()
VE_tracker_dataframe = data.frame()
}
#       (2/4) User choice / Model toggles
####################################################################
rootpath = str_replace(getwd(), "GitHub_vaxAllocation","") #Note: x_results not stored within GitHub repository
complete_model_runs = 1   # when >1 samples randomly from distribution of parameters (where available)
#       (3/4) Run model
#####################################################################
##(A) Initialise setting
if (complete_model_runs == 1){run_type="point"
} else if (complete_model_runs > 1){run_type="rand"}
if (risk_group_toggle == "on"){ num_risk_groups = 2
} else{ num_risk_groups = 1; vax_risk_strategy_toggle = "off"}
if (exists("ticket") == FALSE){ ticket = 1 }
if (exists("prev_setting") == FALSE){ prev_setting = "NONE"}
if (exists("prev_risk_num") == FALSE){ prev_risk_num = "NONE"}
if (exists("prev_risk_group") == FALSE){ prev_risk_group = "NONE"}
if (exists("risk_group_name") == FALSE){ risk_group_name = "NO RISK GROUPS"}
if (exists("prev_run_date") == FALSE){ prev_run_date = as.Date('1900-01-01')}
if (setting != prev_setting | num_risk_groups != prev_risk_num | risk_group_name != prev_risk_group | prev_run_date != Sys.Date()){
source(paste(getwd(),"/(1)_simulate_setting.R",sep="")) #load setting stats if new setting
}
prev_setting = setting
prev_run_date = Sys.Date()
prev_risk_num = num_risk_groups
prev_risk_group = risk_group_name
##(B) Load functions
source(paste(getwd(),"/(function)_COVID_ODE.R",sep=""),local=TRUE)
source(paste(getwd(),"/(function)_VE_time_step.R",sep=""),local=TRUE)
source(paste(getwd(),"/(function)_rho_time_step.R",sep=""),local=TRUE)
source(paste(getwd(),"/(function)_vax_strategies.R",sep=""),local=TRUE)
source(paste(getwd(),"/(function)_vax_strategies_risk.R",sep=""),local=TRUE)
if (exists("VE_estimates_imputed") == FALSE){load(file='1_inputs/VE_estimates_imputed.Rdata')}
##(C) Run the model!
incidence_log_tracker=data.frame()
source(paste(getwd(),"/(3)_disease_characteristics.R",sep=""),local=TRUE)
source(paste(getwd(),"/(2)_inital_state.R",sep=""),local=TRUE)
options(warn = 0) #options = 0 to turn off, 2 to stop at first warning
sol_log = data.frame()
sol_log_unedited = data.frame()
incidence_log = data.frame()
time_step = 1
num_time_steps = model_weeks *7
if (outbreak_timing == "after"){
num_time_steps = model_weeks *7 + as.numeric(max(covid19_waves$date)-date_start) -7
}
D_primary = max(vaccination_history_FINAL$dose[vaccination_history_FINAL$schedule == "primary"])
if (exists("fitting_beta") == FALSE & fitting == "off"){fitting_beta = rep(1,nrow(covid19_waves))}
while(length(fitting_beta) != nrow(covid19_waves) & fitting == "off"){fitting_beta = c(fitting_beta,1)}
#for (increments_number in 1:num_time_steps){
for (increments_number in 1:167){
if (fitting == "on" & increments_number == 1){
parameters = c(
suscept = suscept,
beta=beta,
NPI=NPI_inital,
contact_matrix=contact_matrix,
lota=lota,
gamma=gamma,
lambda=lambda,
delta=delta,
omega=omega,
rho=rho_inital,
age_group_labels=age_group_labels,
risk_group_labels = risk_group_labels,
VE=VE_inital,
# VE_onwards=VE_onwards,
num_age_groups=num_age_groups,
num_risk_groups = num_risk_groups,
num_disease_classes = num_disease_classes,
num_vax_types=num_vax_types,
num_vax_doses=num_vax_doses)
rm(rho_inital,NPI_inital,VE_inital)
sol = as.data.frame(ode(y=state,times=(seq(0,time_step,by=1)),func=covidODE,parms=parameters))
sol_log <- sol
sol_log_unedited <- sol
if (fitting_details == "on"){
Reff <- NA
Reff_tracker = rbind(Reff_tracker,Reff)
colnames(Reff_tracker) <- c('Reff')
}
} else{
date_now = date_start + increments_number*time_step
if (increments_number > 1){
#update NPI
if (date_now <= max(NPI_estimates$date)){
NPI_this_step <- NPI_estimates$NPI[NPI_estimates$date == date_now]/100
parameters$NPI = NPI_this_step
} #i.e. assume after end date that NPI constant
#update VE
if (fitting == "off"){
if ((date_now - min(vaxCovDelay$delay))>= min(vaccination_history_FINAL$date)){
parameters$VE = VE_time_step(strain_now,date_now,'any_infection',
VE_waning_LOCAL = VE_waning_distribution,
vaccination_history_LOCAL = vaccination_history_FINAL,
SA_toggles_local = sensitivity_analysis_toggles)
#gradual shift in VE from omicron to delta
if (date_now %in% omicron_shift$date){
parameters$VE = VE_time_step("delta",date_now,'any_infection',
VE_waning_LOCAL = VE_waning_distribution,
vaccination_history_LOCAL = vaccination_history_FINAL,
SA_toggles_local = sensitivity_analysis_toggles) %>%
rename(delta_VE = VE) %>%
left_join(parameters$VE) %>%
mutate(VE = VE * omicron_shift$percentage[omicron_shift$date == date_now] +
delta_VE * (1-omicron_shift$percentage[omicron_shift$date == date_now])) %>%
select(-delta_VE)
}
}
} else if (fitting == "on"){
parameters$VE = VE_real_range %>% filter(date == date_now)
}
#update rho
if (waning_toggle_rho_acqusition == TRUE ){
parameters$rho = rho_time_step(date_now)
rho = parameters$rho
}
#reconstruct state_tidy
state_working = tail.matrix(sol, 1)
state_working = select(state_working, -time) #remove column with time
state_working = as.vector(state_working)
A = RISK * J * (T * D + 1) # +1 is unvax
S = as.matrix(state_working[1:A])
E = as.matrix(state_working[(A + 1):(2 * A)])
I = as.matrix(state_working[(2 * A + 1):(3 * A)])
R = as.matrix(state_working[(3 * A + 1):(4 * A)])
Incid = as.matrix(state_working[(4 * A + 1):(5 * A)])
prev_state = data.frame()
class_list = list(S, E, I, R)
class_name_list = c('S', 'E', 'I', 'R')
for (i in 1:num_disease_classes) {
workshop = data.frame(pop = class_list[[i]])
row.names(workshop) = NULL
workshop = workshop %>% mutate(class =  class_name_list[i])
workshop$temp = rep(seq(1, (num_age_groups * num_vax_classes)), RISK)
workshop$age_group = rep(age_group_labels, num_vax_classes * RISK)
workshop$dose = 0
workshop$vaccine_type = "unvaccinated"
for (d in 1:num_vax_doses) {
workshop$dose[workshop$temp %in% c((T * (d - 1) + 1) * J + 1):((T * d +
1) * J)] = d
for (t in 1:num_vax_types) {
workshop$vaccine_type[workshop$temp %in% c((((t - 1) + (d - 1) * T + 1) *
J + 1):(((t - 1) + (d - 1) * T + 2) * J))] = vax_type_list[t]
}
}
workshop$risk_group = 'general_public'
if (RISK > 1) {
workshop$risk_group[(num_age_groups * num_vax_classes + 1):(num_age_groups *
num_vax_classes * 2)] = risk_group_name
}
prev_state = rbind(prev_state, workshop)
}
prev_state$pop  = as.numeric(prev_state$pop)
if (round(sum(prev_state$pop)) != sum(pop)) {
stop('prev state not equal to pop size! (~line 105 in time step)')
}
next_state = prev_state # initialise next state
### Include today's primary doses
for (this_risk_group in unique(vaccination_history_FINAL$risk_group)){
for (this_vax in unique(vaccination_history_FINAL$vaccine_type[vaccination_history_FINAL$schedule == "primary"])){  #iterating over vaccine types
this_vax_history = vaccination_history_FINAL %>%
filter(schedule == "primary" &
doses_delivered_this_date >0 &
vaccine_type == this_vax &
risk_group == this_risk_group &
(dose == 1 & date == as.Date(date_now) - vaxCovDelay$delay[vaxCovDelay$dose == 1]|
dose == 2 & date == as.Date(date_now) - vaxCovDelay$delay[vaxCovDelay$dose == 2]))
if(nrow(this_vax_history)>0){
for (this_age_group in unique(this_vax_history$age_group)){
increase = rep(0,D_primary)
for (d in unique(this_vax_history$dose[this_vax_history$age_group == this_age_group])){
increase[d] = this_vax_history$doses_delivered_this_date[this_vax_history$dose == d & this_vax_history$age_group == this_age_group]
}
for (this_class in class_name_list){ #ASSUMPTION: all SEIR vaccinated
prop = rep(0,num_vax_doses) #prop in S,E,I or R in vaccine groups
for (d in 0:D_primary){
if (d==0){
prop[d+1] = prev_state$pop[prev_state$class == this_class & prev_state$risk_group == this_risk_group & prev_state$vaccine_type == "unvaccinated" & prev_state$age_group == this_age_group]/
sum(prev_state$pop[prev_state$vaccine_type == "unvaccinated" & prev_state$risk_group == this_risk_group & prev_state$age_group == this_age_group])
} else{
prop[d+1] = prev_state$pop[prev_state$class == this_class & prev_state$risk_group == this_risk_group & prev_state$vaccine_type == this_vax &  prev_state$dose == d & prev_state$age_group == this_age_group]/
sum(prev_state$pop[prev_state$risk_group == this_risk_group & prev_state$vaccine_type == this_vax & prev_state$dose == d & prev_state$age_group == this_age_group])
}
if (is.nan(prop[d+1]) == TRUE){prop[d+1]=0}
}
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == "unvaccinated" & next_state$age_group == this_age_group] =
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == "unvaccinated" & next_state$age_group == this_age_group] - increase[1]* prop[1]
for (d in 1:(D_primary-1)){
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == d & next_state$age_group == this_age_group] =
next_state$pop[ next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == d & next_state$age_group == this_age_group] + increase[d]*prop[d]-increase[d+1]*prop[d+1]
}
for (d in D_primary){
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == D_primary & next_state$age_group == this_age_group] =
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == D_primary & next_state$age_group == this_age_group] + increase[D_primary] * prop[D_primary]
}
}
}
}
}
}
### Include today's booster doses
todays_boosters = vaccination_history_FINAL %>% filter(schedule == "booster" & doses_delivered_this_date >0 & date == as.Date(date_now) - vaxCovDelay$delay[vaxCovDelay$dose == 2])
if (nrow(todays_boosters)>0){
for (this_risk_group in unique(todays_boosters$risk_group)){
for (this_vax in unique(todays_boosters$vaccine_type)){
for (this_dose in unique(todays_boosters$dose)){
for (from_vax in unique(todays_boosters$FROM_vaccine_type[todays_boosters$vaccine_type == this_vax & todays_boosters$dose == this_dose])){  #iterating over vaccine types FROM
for (from_dose in unique(todays_boosters$FROM_dose[todays_boosters$vaccine_type == this_vax & todays_boosters$dose == this_dose])){
this_vax_history = todays_boosters %>%
filter(FROM_vaccine_type == from_vax &
FROM_dose == from_dose &
risk_group == this_risk_group &
vaccine_type == this_vax &
dose == this_dose &
date == as.Date(date_now) - vaxCovDelay$delay[vaxCovDelay$dose == this_dose])
if (this_dose == 8){this_dose = booster_dose_number}
if (nrow(this_vax_history)>0){
for (this_age_group in unique(this_vax_history$age_group)){ # across age groups
increase = this_vax_history$doses_delivered_this_date[this_vax_history$age_group == this_age_group]
for (this_class in class_name_list){ #let's assume all SEIR vaccinated
prop = prev_state$pop[prev_state$class == this_class & prev_state$risk_group == this_risk_group & prev_state$vaccine_type == from_vax &  prev_state$dose == from_dose & prev_state$age_group == this_age_group]/
sum(prev_state$pop[prev_state$risk_group == this_risk_group & prev_state$vaccine_type == from_vax & prev_state$dose == from_dose & prev_state$age_group == this_age_group])
if (is.nan(prop) == TRUE){prop=0}
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == this_dose & next_state$age_group == this_age_group] =
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == this_vax & next_state$dose == this_dose & next_state$age_group == this_age_group] + increase * prop
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == from_vax & next_state$dose == from_dose & next_state$age_group == this_age_group] =
next_state$pop[next_state$class == this_class & next_state$risk_group == this_risk_group & next_state$vaccine_type == from_vax & next_state$dose == from_dose & next_state$age_group == this_age_group] - increase * prop
}
}
}
}
}
}
}
}
rm(from_vax,from_dose,this_vax_history, this_risk_group, this_vax, this_age_group, increase, this_class, prop)
}
if (fitting == "on" & date_now == as.Date('2021-11-14')){next_state_FIT = next_state} #savings to compare against known point of seroprevalence
if (date_now %in% covid19_waves$date){
if (date_now == min(covid19_waves$date[covid19_waves$strain == "delta"])){
strain_now = 'delta'
} else if (date_now == min(covid19_waves$date[covid19_waves$strain == "omicron"])){
strain_now = 'omicron'
#parameters$lambda = 1/2.22 #COMEBACK - hard coded :(
#parameters$delta = 1/9.87
}
prev_beta = parameters$beta
parameters$beta = rep(beta_fitted_values$beta_optimised[beta_fitted_values$strain == strain_now],num_age_groups)*
fitting_beta[which(covid19_waves$date == date_now)]
this_beta = parameters$beta
seed.Infected = seed*AverageSymptomaticPeriod/(AverageSymptomaticPeriod+AverageLatentPeriod)
seed.Exposed  = seed*AverageLatentPeriod/(AverageSymptomaticPeriod+AverageLatentPeriod)
#ASSUMPTION: uniform across age groups
seed.Infected = round(seed.Infected * pop/sum(pop))
seed.Exposed = round(seed.Exposed * pop/sum(pop))
for (i in 1:num_age_groups){ # across age groups
infect = seed.Infected[i]
expose = seed.Exposed[i]
infect = round(infect * next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] /sum(next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]]))
expose = round(expose * next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] /sum(next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]]))
next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] - infect - expose
next_state$pop[next_state$class == 'I'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'I'  & next_state$age_group == age_group_labels[i]] + infect
next_state$pop[next_state$class == 'E'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'E'  & next_state$age_group == age_group_labels[i]] + expose
}
}
#shift from delta to omicron parameters
if (date_now %in% omicron_shift$date){
parameters$lambda = 1/2.22*omicron_shift$percentage[omicron_shift$date == date_now] +
1/3.71 * (1-omicron_shift$percentage[omicron_shift$date == date_now])
parameters$delta = 1/9.87*omicron_shift$percentage[omicron_shift$date == date_now] +
1/10.9 * (1-omicron_shift$percentage[omicron_shift$date == date_now])
parameters$beta = this_beta*omicron_shift$percentage[omicron_shift$date == date_now] + prev_beta * (1-omicron_shift$percentage[omicron_shift$date == date_now])
}
# if (fitting == "off"){
#   if (date_now>=seed_date){
#     parameters$VE$VE = parameters$VE$VE * 0.9
#     parameters$rho = parameters$rho * 0.9
#   }
# }
if (round(sum(next_state$pop)) != round(sum(prev_state$pop))) {
stop('pop not retained between next_state and prev_state!')
}
if (round(sum(next_state$pop)) != sum(pop)) {
stop('pop in next_state not equal to setting population')
}
if (nrow(next_state[round(next_state$pop) < 0, ]) > 0) {
if (date_now > max(vaccination_history_TRUE$date + max(vaxCovDelay$delay))) {
stop('(4)_time_step line ~290')
} else{
if (nrow(next_state[round(next_state$pop) < -100, ]) > 0) {#Note: some negatives expected here due to recreation of vaccination_history
warning('(4)_time_step line ~290, possibility to do with vaccination_history configuration')
}
}
}
# convert back into untidy long vector form for ODE solver
workshop = next_state
workshop$class = factor(workshop$class, levels = disease_class_list)
workshop$risk_group = factor(workshop$risk_group, levels = risk_group_labels)
workshop$vaccine_type = factor(workshop$vaccine_type, levels = vax_type_list)
workshop$age_group = factor(workshop$age_group, levels = age_group_labels)
next_state = workshop %>% arrange(class, risk_group, dose, vaccine_type, age_group)
S_next = next_state$pop[next_state$class == 'S']
E_next = next_state$pop[next_state$class == 'E']
I_next = next_state$pop[next_state$class == 'I']
R_next = next_state$pop[next_state$class == 'R']
next_state_FINAL=as.numeric(c(S_next,E_next,I_next,R_next,
Incidence_inital,Exposed_incidence_inital)) #setting Incid to repeated 0s
rm(S_next,E_next,I_next,R_next)
}
# next time_step!
sol <- as.data.frame(ode(y=next_state_FINAL,times=(seq(0,time_step,by=1)),func=covidODE,parms=parameters))
sol[,1]=sol[,1]+time_step*(increments_number-1) #make times correct
if (increments_number>1){ sol_log=head(sol_log,-1) }#remove last entry from sol_log (overlap of runs)
sol_log <- rbind(sol_log,sol)
sol_log_unedited <- rbind(sol_log_unedited,sol)
### INCIDENCE CALCULATIONS
J = num_age_groups
T = num_vax_types
D = num_vax_doses
RISK = num_risk_groups
A = RISK * J * (T * D + 1) # +1 is unvax
incidence_log_unedited <- sol_log_unedited[, c(1,(A*num_disease_classes+2):(A*(num_disease_classes+1)+1))]
incidence_log_unedited <- incidence_log_unedited %>% filter (time %% time_step == 0, rowSums(incidence_log_unedited) != time)
incidence_log_unedited <- distinct(round(incidence_log_unedited,digits=2))
incidence_log_unedited$date <- date_start + incidence_log_unedited$time
incidence_log_unedited$daily_cases  <- rowSums(incidence_log_unedited[,2:(A+1)])
incidence_log <- incidence_log_unedited %>% select(date,daily_cases)
if (! fitting == "on"){incidence_log = rbind(fitted_incidence_log,incidence_log)}
incidence_log = incidence_log %>%
mutate(rolling_average = (daily_cases + lag(daily_cases) + lag(daily_cases,n=2)+lag(daily_cases,n=3)
+lag(daily_cases,n=4)+lag(daily_cases,n=5)+lag(daily_cases,n=6))/7,
rolling_average_percentage = 100*rolling_average/sum(pop),
cumulative_incidence = cumsum(daily_cases),
cumulative_incidence_percentage = 100*cumsum(daily_cases)/sum(pop))
if (fitting_details == "on"){
Reff <- Reff_time_step(parameters, next_state)
Reff_tracker = rbind(Reff_tracker, Reff)
rho_tracker_dataframe = rbind(rho_tracker_dataframe,parameters$rho)
workshop = parameters$VE
workshop = workshop[workshop$VE > 0, ] %>% mutate(immunity = paste(vaccine_type, dose))
if (nrow(workshop) > 0) {
workshop = aggregate(workshop$VE,
by = list(category = workshop$immunity),
FUN = mean)
colnames(workshop) = c('dose', 'VE')
workshop$date = date_now
VE_tracker_dataframe = rbind(VE_tracker_dataframe, workshop)
}
}
}
} ### END INCREMENT (#incidence log moved within loop to allow rho_time_step to access)
parameters$beta
parameters$beta1
parameters$beta
parameters$beta1
fitting_beta
colnames(parameters)
parameters
parameters$beta1
parameters$beta1
prev_beta = c(parameters$beta1,parameters$beta2)
prev_beta
prev_beta = rep(parameters$beta1,J)
prev_beta
if (date_now %in% covid19_waves$date){
if (date_now == min(covid19_waves$date[covid19_waves$strain == "delta"])){
strain_now = 'delta'
} else if (date_now == min(covid19_waves$date[covid19_waves$strain == "omicron"])){
strain_now = 'omicron'
#parameters$lambda = 1/2.22 #COMEBACK - hard coded :(
#parameters$delta = 1/9.87
}
prev_beta = rep(parameters$beta1,J)
parameters$beta = rep(beta_fitted_values$beta_optimised[beta_fitted_values$strain == strain_now],num_age_groups)*
fitting_beta[which(covid19_waves$date == date_now)]
this_beta = parameters$beta
seed.Infected = seed*AverageSymptomaticPeriod/(AverageSymptomaticPeriod+AverageLatentPeriod)
seed.Exposed  = seed*AverageLatentPeriod/(AverageSymptomaticPeriod+AverageLatentPeriod)
#ASSUMPTION: uniform across age groups
seed.Infected = round(seed.Infected * pop/sum(pop))
seed.Exposed = round(seed.Exposed * pop/sum(pop))
for (i in 1:num_age_groups){ # across age groups
infect = seed.Infected[i]
expose = seed.Exposed[i]
infect = round(infect * next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] /sum(next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]]))
expose = round(expose * next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] /sum(next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]]))
next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'S'  & next_state$age_group == age_group_labels[i]] - infect - expose
next_state$pop[next_state$class == 'I'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'I'  & next_state$age_group == age_group_labels[i]] + infect
next_state$pop[next_state$class == 'E'  & next_state$age_group == age_group_labels[i]] = next_state$pop[next_state$class == 'E'  & next_state$age_group == age_group_labels[i]] + expose
}
}
parameters$beta
prev_beta
parameters$beta = rep(beta_fitted_values$beta_optimised[beta_fitted_values$strain == strain_now],num_age_groups)*
fitting_beta[which(covid19_waves$date == date_now)]
parameters$beta
rep(beta_fitted_values$beta_optimised[beta_fitted_values$strain == strain_now],num_age_groups)
fitting_beta[which(covid19_waves$date == date_now)]
date_now
date_now %in% covid19_waves$date
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(4)_time_step.R", echo=TRUE)
source(paste(getwd(),"/CommandDeck.R",sep=""),local=TRUE)
date_now
#FIT SECOND WAVE_______________________________
if (exists("fitting_beta")){rm(fitting_beta)}
if (exists("under_reporting_est")){rm(under_reporting_est)}
if (exists("covid19_waves")){rm(covid19_waves)}
fit_daily_reported <- function(par){
load(file = paste('1_inputs/fit/first_wave_fit',this_setting,'.Rdata',sep=''))
strain_inital = strain_now = 'WT'
model_weeks =as.numeric((fit_cutoff_dates[2]-date_start)/7)
covid19_waves = data.frame(date = c(as.Date('2021-06-09')+first_wave_fit$par[1],
as.Date('2021-10-15')+par[1]),
strain = c('delta','omicron'))
under_reporting_est = par[2]
fitting_beta= c(first_wave_fit$par[3],par[3])
source(paste(getwd(),"/CommandDeck.R",sep=""),local=TRUE)
workshop = case_history %>%
filter(date > fit_cutoff_dates[1]) %>% #fit only after first wave
select(date,rolling_average) %>%
mutate(#under_reporting_est = coeff1 + coeff2*as.numeric(date - date_start), #linear
rolling_average = rolling_average * under_reporting_est) %>%
rename(adjusted_reported = rolling_average) %>%
left_join(incidence_log, by = "date") %>%
mutate(fit_statistic = abs(rolling_average - adjusted_reported)^2)
fit_statistic = sum(workshop$fit_statistic,na.rm=TRUE)
return(fit_statistic)
}
system.time({second_wave_fit = optim(c(0,40,1),
fit_daily_reported,
method = "Nelder-Mead")})
336310.29 /60/60
second_wave_fit
par
second_wave_fit$par
first_wave_fit
rm(par)
par
fitting_beta
under_reporting_est
covid19_waves
second_wave_fit
par
load(file = paste('1_inputs/fit/first_wave_fit',this_setting,'.Rdata',sep=''))
par
first_wave_fit
fit_daily_reported <- function(par){
load(file = paste('1_inputs/fit/first_wave_fit',this_setting,'.Rdata',sep=''))
strain_inital = strain_now = 'WT'
model_weeks =as.numeric((fit_cutoff_dates[2]-date_start)/7)
covid19_waves = data.frame(date = c(as.Date('2021-06-09')+first_wave_fit$par[1],
as.Date('2021-10-15')+par[1]),
strain = c('delta','omicron'))
under_reporting_est = par[2]
fitting_beta= c(first_wave_fit$par[3],par[3])
source(paste(getwd(),"/CommandDeck.R",sep=""),local=TRUE)
workshop = case_history %>%
filter(date > fit_cutoff_dates[1]) %>% #fit only after first wave
select(date,rolling_average) %>%
mutate(#under_reporting_est = coeff1 + coeff2*as.numeric(date - date_start), #linear
rolling_average = rolling_average * under_reporting_est) %>%
rename(adjusted_reported = rolling_average) %>%
left_join(incidence_log, by = "date") %>%
mutate(fit_statistic = abs(rolling_average - adjusted_reported)^2)
fit_statistic = sum(workshop$fit_statistic,na.rm=TRUE)
return(fit_statistic)
}
system.time({second_wave_fit = optim(c(0,40,1),
fit_daily_reported,
method = "Nelder-Mead")})
279677.81 /60/60
second_wave_fit
warnings()
