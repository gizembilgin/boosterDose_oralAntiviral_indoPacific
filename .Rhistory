# prop dose one
prop2 = prev_state$pop[prev_state$class == class & prev_state$risk_group == this_risk_group & prev_state$vaccine_type == vax_type_list[t] & prev_state$dose == 1 & prev_state$age_group == age_group_labels[i]]/
sum(prev_state$pop[prev_state$risk_group == this_risk_group & prev_state$vaccine_type == vax_type_list[t] & prev_state$dose == 1 & prev_state$age_group == age_group_labels[i]])
if (is.nan(prop1) == TRUE){prop1=0}
if (is.nan(prop2) == TRUE){prop2=0}
next_state$pop[next_state$class == class & prev_state$risk_group == this_risk_group & next_state$vaccine_type == "unvaccinated" & next_state$age_group == age_group_labels[i]] =
next_state$pop[next_state$class == class & prev_state$risk_group == this_risk_group & next_state$vaccine_type == "unvaccinated" & next_state$age_group == age_group_labels[i]] - increase_one*prop1
next_state$pop[next_state$vaccine_type == vax_type_list[t] & next_state$class == class & prev_state$risk_group == this_risk_group & next_state$dose == 1 & next_state$age_group == age_group_labels[i]] =
next_state$pop[next_state$vaccine_type == vax_type_list[t] & next_state$class == class & prev_state$risk_group == this_risk_group & next_state$dose == 1 & next_state$age_group == age_group_labels[i]] + increase_one*prop1-increase_two*prop2
next_state$pop[next_state$vaccine_type == vax_type_list[t] & next_state$class == class & prev_state$risk_group == this_risk_group & next_state$dose == 2 & next_state$age_group == age_group_labels[i]] =
next_state$pop[next_state$vaccine_type == vax_type_list[t] & next_state$class == class & prev_state$risk_group == this_risk_group & next_state$dose == 2 & next_state$age_group == age_group_labels[i]] + increase_two * prop2
}
}
}
}
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(4)_time_step.R", echo=TRUE)
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", echo=TRUE)
increments_number
date_now = date_start + increments_number*time_step
if (date_now <= max(NPI_estimates$date)){
NPI_this_step <- NPI_estimates$NPI[NPI_estimates$date == date_now]/100
parameters$NPI = NPI_this_step
} #i.e. assume after end date that NPI constant
if ((date_now - min(vaccine_coverage_delay))>= min(vaccination_history_FINAL$date)){
parameters$VE = VE_time_step(strain,date_now,'any_infection')
}
# selecting bottom row of solution which is time = 7 (one week)
state_working=tail.matrix(sol,1)
state_working=select(state_working,-time) #remove column with time
state_working=as.vector(state_working)
# lets reconstruct our matrix (easier to work with)
A=RISK*J*(T*D+1) # +1 is unvax
S = as.matrix(state_working[1:A])
E = as.matrix(state_working[(A+1):(2*A)])
I = as.matrix(state_working[(2*A+1):(3*A)])
R = as.matrix(state_working[(3*A+1):(4*A)])
Incid = as.matrix(state_working[(4*A+1):(5*A)])
sum(S+E+I+R)
sum(pop)
date_now = date_start + increments_number*time_step
if (date_now <= max(NPI_estimates$date)){
NPI_this_step <- NPI_estimates$NPI[NPI_estimates$date == date_now]/100
parameters$NPI = NPI_this_step
} #i.e. assume after end date that NPI constant
if ((date_now - min(vaccine_coverage_delay))>= min(vaccination_history_FINAL$date)){
parameters$VE = VE_time_step(strain,date_now,'any_infection')
}
# selecting bottom row of solution which is time = 7 (one week)
state_working=tail.matrix(sol,1)
state_working=select(state_working,-time) #remove column with time
state_working=as.vector(state_working)
# lets reconstruct our matrix (easier to work with)
A=RISK*J*(T*D+1) # +1 is unvax
S = as.matrix(state_working[1:A])
E = as.matrix(state_working[(A+1):(2*A)])
I = as.matrix(state_working[(2*A+1):(3*A)])
R = as.matrix(state_working[(3*A+1):(4*A)])
Incid = as.matrix(state_working[(4*A+1):(5*A)])
#back to tidy form!
prev_state = data.frame()
class_list = list(S,E,I,R)
class_name_list = c('S','E','I','R')
#HERE!!!
for (i in 1:num_disease_classes){
workshop = data.frame(t(class_list[[i]]))
colnames(workshop) = c('pop')
workshop$class = class_name_list[i]
workshop$temp = rep(seq(1,(num_age_groups*num_vax_classes)),RISK)
workshop$age_group = rep(age_group_labels,num_vax_classes*RISK)
workshop$dose = 0
workshop$vaccine_type = "unvaccinated"
for (d in 1:num_vax_doses){
workshop$dose[workshop$temp %in% c((T*(d-1)+1)*J+1):((T*d+1)*J)] = d
for (t in 1:num_vax_types){
workshop$vaccine_type[workshop$temp %in% c((((t-1)+(d-1)*T+1)*J+1):(((t-1)+(d-1)*T+2)*J))] = vax_type_list[t]
}
}
workshop$risk_group = 'general public'
if (RISK>1){
workshop$risk_group[(num_age_groups*num_vax_classes+1):(num_age_groups*num_vax_classes*2)] = risk_group_toggle
}
prev_state = rbind(prev_state,workshop)
}
if (sum(prev_state$pop)!= sum(pop)){stop('prev state not equal to pop size! (~line 100 in time step)')}
next_state=prev_state # initialise next state
sum(S+E+I+R)
sum(pop)
sum(prev_state$pop
)
sum(prev_state$pop)!= sum(pop)
sum(prev_state$pop)
sum(pop)
if (round(sum(prev_state$pop))!= sum(pop)){stop('prev state not equal to pop size! (~line 100 in time step)')}
round(sum(prev_state$pop))!= sum(pop)
sum(prev_state$pop)!= sum(pop)
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", echo=TRUE)
if (sum(next_state$pop)!= sum(pop)) {stop('pop in next_state not equal to setting population')}
sum(next_state$pop)!= sum(pop)
sum(next_state$pop)
if (round(sum(next_state$pop))!= sum(pop)) {stop('pop in next_state not equal to setting population')}
if(nrow(next_state[round(next_state$pop)<0,])>0){ stop('issue in vaccination in (4)_time_step')}
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", echo=TRUE)
increments_number
View(next_state)
sum(next_state$pop)
sum(prev_state$pop)
if (round(sum(next_state$pop))!= round(sum(prev_state$pop))){stop('pop not retained between next_state and prev_state!')}
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", echo=TRUE)
187/60
ticket
ticket = 1
#raw number - daily and cumulative
plot1 <- ggplot() +
geom_line(data=incidence_log,aes(x=date,y=rolling_average),na.rm=TRUE) +
geom_point(data=case_history[case_history$date>date_start & case_history$date <max(incidence_log$date),],
aes(x=date,y=rolling_average*underascertainment_est),na.rm=TRUE) +
xlab("") +
scale_x_date(date_breaks="1 month", date_labels="%b") +
ylab("daily cases") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black'))
plot2 <- ggplot() +
geom_line(data=incidence_log,aes(x=date,y=cumulative_incidence),na.rm=TRUE) +
xlab("") +
scale_x_date(date_breaks="1 month", date_labels="%b") +
ylab("cumulative cases") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black'))
#grid.arrange(plot1, plot2, nrow=2)
#number as % of whole population
lay <- rbind(c(1,2),c(3,3))
plot1 <-
ggplot() +
geom_line(data=incidence_log,aes(x=date,y=rolling_average_percentage),na.rm=TRUE) +
geom_point(data=case_history[case_history$date>date_start & case_history$date <max(incidence_log$date),],
aes(x=date,y=rolling_average*100*underascertainment_est/sum(pop)),na.rm=TRUE) +
xlab("") +
scale_x_date(date_breaks="1 month", date_labels="%b") +
ylab("daily cases % whole pop") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black'))
plot2 <- ggplot() +
geom_line(data=incidence_log,aes(x=date,y=Reff),na.rm=TRUE) +
xlab("") +
scale_x_date(date_breaks="1 month", date_labels="%b") +
#ylim(0,6) +
ylab("Reff") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black'))
plot3<- ggplot() +
geom_line(data=incidence_log,aes(x=date,y=cumulative_incidence_percentage),na.rm=TRUE) +
xlab("") +
scale_x_date(date_breaks="1 month", date_labels="%b") +
ylab("cumulative cases % whole pop") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black'))
grid.arrange(plot1, plot2, plot3, layout_matrix = lay)
}
#either incidence per 100,000 or % of total population
#__________________________________________________________________
time.end=proc.time()[[3]]
time.end-time.start
## current runtime (23/03) 3 minutes for 52 weeks
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", echo=TRUE)
#       (1/4) Setup
####################################################################
#load libraries
library(tidyverse)
library(readr)
library(deSolve)
library(rvest)
library(ggplot2)
library(gridExtra)
library(ggpubr)
#rm(list=ls())  # clear global environment
if (Sys.info()[['user']] == 'u6044061'){ rootpath = 'C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/'
}else if (Sys.info()[['user']] == 'gizem'){ rootpath = 'C:/Users/gizem/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/'}
#_________________________________________________________________
#       (2/4) User choice / Model toggles
####################################################################
setting = "SLE"
if(outbreak_post_rollout == "on"){
date_start = max(vaccination_history_FINAL$date)
seed_date = date_start
}else if(outbreak_post_rollout == "off"){ #i.e. rolling out vaccine during outbreak
date_start = as.Date('2022-04-15')
#date_start = max(vaccination_history_FINAL$date)
#seed_date = vax_strategy_start_date+365/2
seed_date = date_start
}
strain_inital = 'omicron'             #options:'WT','delta','omicron'
model_weeks = 52          # how many weeks should the model run for?
complete_model_runs = 1   # when >1 samples randomly from distribution of parameters (where available)
NPI_outbreak_toggle = "delta_peaks"   #options: final, delta_peaks
underascertainment_est = 43
behaviour_mod = 0  #0.268 if start 01/03/21
uniform_mod=1
#vax_strategy_plot = "off" #included in (plot)_vax_strategies
#__________________________________________________________________
#       (3/4) Run model
# ####################################################################
##(A) Load functions
source(paste(getwd(),"/(function)_COVID_ODE.R",sep=""))
source(paste(getwd(),"/(function)_VE_time_step.R",sep=""))
source(paste(getwd(),"/(function)_vax_strategies.R",sep=""))
##(B) Simulate setting
# time saving tactics! Load setting if not yet loaded
if (complete_model_runs == 1){run_type="point"
} else if (complete_model_runs > 1){run_type="rand"}
if (setting == "PNG"){setting_long = "Papua New Guinea"
} else if (setting == "SLE"){setting_long = "Sierra Leone"}
if (exists("prev_setting") == FALSE){ prev_setting = "NONE"}
if (setting != prev_setting){source(paste(getwd(),"/(1)_simulate_setting.R",sep=""))} #load setting stats if new setting
prev_setting = setting
#making some interim variables to assist with configuring states
seed = 0.001*sum(pop)
num_risk_groups = 2☻                                     # if >1 then a risk group, either pregnant women or comorbidities included
risk_group_toggle = "pregnant_women"
num_disease_classes = 4                                 # SEIR
num_vax_doses = D = length(unique(vaccination_history_TRUE$dose))  # dose 1, dose 2, COMEBACK no boosters yet in these settings
vax_type_list = sort(unique(vaccination_history_TRUE$vaccine_type))
num_vax_types = T = length(unique(vaccination_history_TRUE$vaccine_type))
num_vax_classes = num_vax_doses*num_vax_types + 1                 # + 1 for unvaccinated
num_total_classes = (num_disease_classes+1)*(num_age_groups*num_vax_classes)*num_risk_groups #+1 for incidence tracker
num_risk_groups = 2                                     # if >1 then a risk group, either pregnant women or comorbidities included
risk_group_toggle = "pregnant_women"
num_disease_classes = 4                                 # SEIR
num_vax_doses = D = length(unique(vaccination_history_TRUE$dose))  # dose 1, dose 2, COMEBACK no boosters yet in these settings
vax_type_list = sort(unique(vaccination_history_TRUE$vaccine_type))
num_vax_types = T = length(unique(vaccination_history_TRUE$vaccine_type))
num_vax_classes = num_vax_doses*num_vax_types + 1                 # + 1 for unvaccinated
num_total_classes = (num_disease_classes+1)*(num_age_groups*num_vax_classes)*num_risk_groups #+1 for incidence tracker
source(paste(getwd(),"/(3)_disease_characteristics.R",sep=""))
source(paste(getwd(),"/(2)_inital_state.R",sep=""))
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(4)_time_step.R", echo=TRUE)
increments_number
sol = as.data.frame(ode(y=state,times=(seq(0,time_step,by=1)),func=covidODE,parms=parameters))
state
A
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", echo=TRUE)
date_now
### INCIDENCE CALCULATIONS
J=num_age_groups
T=num_vax_types
D=num_vax_doses
RISK=num_risk_groups
A=RISK*J*(T*D+1) # +1 is unvax
#WEEKLY
#Incid by age and vax class
incidence_log_unedited <- sol_log_unedited[, c(1,(A*4+2):(A*5+1))]
# select weekly end points
incidence_log_unedited <- incidence_log_unedited %>% filter (time %% time_step == 0, rowSums(incidence_log_unedited) != time)
incidence_log_unedited <- distinct(round(incidence_log_unedited,digits=2))
incidence_log_unedited$date <- date_start + incidence_log_unedited$time
incidence_log_unedited$daily_cases  <- rowSums(incidence_log_unedited[,2:(A+1)])
incidence_log <- incidence_log_unedited %>%
select(date,daily_cases) %>%
mutate(rolling_average = (daily_cases + lag(daily_cases) + lag(daily_cases,n=2)+lag(daily_cases,n=3)
+lag(daily_cases,n=4)+lag(daily_cases,n=5)+lag(daily_cases,n=6))/7) %>%
mutate(rolling_average_percentage = 100*rolling_average/sum(pop)) %>%
mutate(cumulative_incidence = cumsum(daily_cases)) %>%
mutate(cumulative_incidence_percentage = 100*cumsum(daily_cases)/sum(pop))
incidence_log <- cbind(incidence_log,Reff_tracker)
check <- sol_log_unedited
check$Incid = rowSums(sol_log_unedited[,(A*4+2):(A*5+1)])
check$R = rowSums(sol_log_unedited[,(A*3+2):(A*4+1)])
check$I = rowSums(sol_log_unedited[,(A*2+2):(A*3+1)])
check$E = rowSums(sol_log_unedited[,(A+2):(A*2+1)])
check$S = rowSums(sol_log_unedited[,2:(A+1)])
check = check %>% select(S,E,I,R,Incid) %>%
mutate(pop = S + E + I + R)
### INCIDENCE LOG TIDY
workshop = subset(incidence_log_unedited, select=-c(time,daily_cases))
workshop = pivot_longer(
workshop,
cols = paste((num_disease_classes)*(num_age_groups*num_vax_classes)+1):paste((num_disease_classes+1)*(num_age_groups*num_vax_classes)),
names_to = 'temp',
values_to = 'incidence'
)
### INCIDENCE LOG TIDY
workshop = subset(incidence_log_unedited, select=-c(time,daily_cases))
workshop = pivot_longer(
workshop,
cols = paste((num_disease_classes)*(num_age_groups*num_vax_classes)+1):paste((num_disease_classes+1)*(num_age_groups*num_vax_classes)),
names_to = 'temp',
values_to = 'incidence'
)
(num_disease_classes)*(num_age_groups*num_vax_classes)+1)
### INCIDENCE LOG TIDY
workshop = subset(incidence_log_unedited, select=-c(time,daily_cases))
View(workshop)
(num_disease_classes)*(num_age_groups*num_vax_classes)+1)
(num_disease_classes)*(num_age_groups*num_vax_classes)+1
RISK*(num_disease_classes)*(num_age_groups*num_vax_classes)+1
(num_disease_classes+1)*(num_age_groups*num_vax_classes)*RISK
#HERE - ERROR
workshop = pivot_longer(
workshop,
cols = paste((num_disease_classes)*(num_age_groups*num_vax_classes)*RISK+1):paste((num_disease_classes+1)*(num_age_groups*num_vax_classes)*RISK),
names_to = 'temp',
values_to = 'incidence'
)
#HERE - ERROR
workshop = pivot_longer(
workshop,
cols = paste((num_disease_classes)*(num_age_groups*num_vax_classes)*RISK+1):paste((num_disease_classes+1)*(num_age_groups*num_vax_classes)*RISK),
names_to = 'temp',
values_to = 'incidence'
)
### INCIDENCE LOG TIDY
workshop = subset(incidence_log_unedited, select=-c(time,daily_cases))
#HERE - ERROR
workshop = pivot_longer(
workshop,
cols = paste((num_disease_classes)*(num_age_groups*num_vax_classes)*RISK+1):paste((num_disease_classes+1)*(num_age_groups*num_vax_classes)*RISK),
names_to = 'temp',
values_to = 'incidence'
)
(num_disease_classes)*(num_age_groups*num_vax_classes)*RISK+1
(num_disease_classes)*(num_age_groups*num_vax_classes)*RISK+1
(num_disease_classes+1)*(num_age_groups*num_vax_classes)*RISK
paste((num_disease_classes)*(num_age_groups*num_vax_classes)*RISK+1):paste((num_disease_classes+1)*(num_age_groups*num_vax_classes)*RISK)
colnames(workshop)
### INCIDENCE LOG TIDY
workshop = subset(incidence_log_unedited, select=-c(time,daily_cases))
colnames(workshop)
#HERE - ERROR
workshop = pivot_longer(
workshop,
cols = paste((num_disease_classes)*(num_age_groups*num_vax_classes)*RISK+1):paste((num_disease_classes+1)*(num_age_groups*num_vax_classes)*RISK),
names_to = 'temp',
values_to = 'incidence'
)
View(workshop)
(num_disease_classes)*(num_age_groups*num_vax_classes)
workshop$temp = as.numeric(workshop$temp) - (num_disease_classes)*(num_age_groups*num_vax_classes)*RISK
workshop2=as.data.frame(unique(workshop$temp)); colnames(workshop2)=c('temp')
workshop2$age_group = rep(age_group_labels,num_vax_classes) #smallest subdivision is age
View(workshop)
View(workshop2)
workshop$temp_riskStill =  rep(seq(1,(num_age_groups*num_vax_classes)),RISK)
rep(seq(1,(num_age_groups*num_vax_classes)),RISK)
### INCIDENCE LOG TIDY
workshop = subset(incidence_log_unedited, select=-c(time,daily_cases))
#HERE - ERROR
workshop = pivot_longer(
workshop,
cols = paste((num_disease_classes)*(num_age_groups*num_vax_classes)*RISK+1):paste((num_disease_classes+1)*(num_age_groups*num_vax_classes)*RISK),
names_to = 'temp',
values_to = 'incidence'
)
workshop$temp = as.numeric(workshop$temp) - (num_disease_classes)*(num_age_groups*num_vax_classes)*RISK
(num_age_groups*num_vax_classes))*RISK
(num_age_groups*num_vax_classes)*RISK
if (check$pop[1] !=sum(pop)){stop('ERROR: see line 276 of (4) timestep')}
library(tidyverse)
library(readr)
library(deSolve)
library(rvest)
library(ggplot2)
library(gridExtra)
library(ggpubr)
### INCIDENCE LOG TIDY
workshop = subset(incidence_log_unedited, select=-c(time,daily_cases))
workshop = pivot_longer(
workshop,
cols = paste((num_disease_classes)*(num_age_groups*num_vax_classes)*RISK+1):paste((num_disease_classes+1)*(num_age_groups*num_vax_classes)*RISK),
names_to = 'temp',
values_to = 'incidence'
)
workshop$temp = as.numeric(workshop$temp) - (num_disease_classes)*(num_age_groups*num_vax_classes)*RISK
#HERE - ERROR need to align!
workshop2=as.data.frame(unique(workshop$temp)); colnames(workshop2)=c('temp')
View(workshop2)
#HERE - ERROR need to align!
workshop2=as.data.frame(unique(workshop$temp)); colnames(workshop2)=c('temp')
workshop2$age_group = rep(age_group_labels,num_vax_classes) #smallest subdivision is age
workshop2$dose = 0                                          #then dose
workshop2$vaccine_type = "unvaccinated"                     #then vaccine type
for (d in 1:num_vax_doses){
workshop2$dose[workshop2$temp %in% c((T*(d-1)+1)*J+1):((T*d+1)*J)] = d
for (t in 1:num_vax_types){
workshop2$vaccine_type[workshop2$temp %in% c((((t-1)+(d-1)*T+1)*J+1):(((t-1)+(d-1)*T+2)*J))] = vax_type_list[t]
}
}
(num_disease_classes)*(num_age_groups*num_vax_classes)*RISK
workshop2 = workshop2 %>%
mutate(temp_risk = case_when(
temp <= max(workshop$temp)/2 ~ temp,
temp > max(workshop$temp)/2  ~ temp - max(workshop$temp)/2
))
#HERE - ERROR need to align!
workshop2=as.data.frame(unique(workshop$temp)); colnames(workshop2)=c('temp')
workshop2 = workshop2 %>%
mutate(temp_risk = case_when(
temp <= max(workshop$temp)/2 ~ temp,
temp > max(workshop$temp)/2  ~ temp - max(workshop$temp)/2
))
workshop2$age_group = rep(age_group_labels,num_vax_classes) #smallest subdivision is age
workshop2$dose = 0                                          #then dose
workshop2$vaccine_type = "unvaccinated"                     #then vaccine type
for (d in 1:num_vax_doses){
workshop2$dose[workshop2$temp_risk %in% c((T*(d-1)+1)*J+1):((T*d+1)*J)] = d
for (t in 1:num_vax_types){
workshop2$vaccine_type[workshop2$temp_risk %in% c((((t-1)+(d-1)*T+1)*J+1):(((t-1)+(d-1)*T+2)*J))] = vax_type_list[t]
}
}
#View(workshop2)
#HERE - ERROR need to align!
workshop2=as.data.frame(unique(workshop$temp)); colnames(workshop2)=c('temp')
if (RISK == 1){
workshop2 = workshop2 %>%   mutate(temp_risk = temp, risk_group = risk_group_list[[1]])
} else {
workshop2 = workshop2 %>%
mutate(temp_risk = case_when(
temp <= max(workshop$temp)/2 ~ temp,
temp > max(workshop$temp)/2  ~ temp - max(workshop$temp)/2
),
risk_group = case_when(
temp <= max(workshop$temp)/2 ~ risk_group_list[[1]],
temp > max(workshop$temp)/2  ~ risk_group_list[[2]]
))
}
workshop2$age_group = rep(age_group_labels,num_vax_classes) #smallest subdivision is age
workshop2$dose = 0                                          #then dose
workshop2$vaccine_type = "unvaccinated"                     #then vaccine type
for (d in 1:num_vax_doses){
workshop2$dose[workshop2$temp_risk %in% c((T*(d-1)+1)*J+1):((T*d+1)*J)] = d
for (t in 1:num_vax_types){
workshop2$vaccine_type[workshop2$temp_risk %in% c((((t-1)+(d-1)*T+1)*J+1):(((t-1)+(d-1)*T+2)*J))] = vax_type_list[t]
}
}
incidence_log_tidy = workshop %>% left_join(workshop2)
incidence_log_tidy = subset(incidence_log_tidy,select=-c(temp))
plot1 <- ggplot() +
geom_line(data=incidence_log,aes(x=date,y=rolling_average),na.rm=TRUE) +
geom_point(data=case_history[case_history$date>date_start & case_history$date <max(incidence_log$date),],
aes(x=date,y=rolling_average*underascertainment_est),na.rm=TRUE) +
xlab("") +
scale_x_date(date_breaks="1 month", date_labels="%b") +
ylab("daily cases") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black'))
plot2 <- ggplot() +
geom_line(data=incidence_log,aes(x=date,y=cumulative_incidence),na.rm=TRUE) +
xlab("") +
scale_x_date(date_breaks="1 month", date_labels="%b") +
ylab("cumulative cases") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black'))
#grid.arrange(plot1, plot2, nrow=2)
#number as % of whole population
lay <- rbind(c(1,2),c(3,3))
plot1 <-
ggplot() +
geom_line(data=incidence_log,aes(x=date,y=rolling_average_percentage),na.rm=TRUE) +
geom_point(data=case_history[case_history$date>date_start & case_history$date <max(incidence_log$date),],
aes(x=date,y=rolling_average*100*underascertainment_est/sum(pop)),na.rm=TRUE) +
xlab("") +
scale_x_date(date_breaks="1 month", date_labels="%b") +
ylab("daily cases % whole pop") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black'))
plot2 <- ggplot() +
geom_line(data=incidence_log,aes(x=date,y=Reff),na.rm=TRUE) +
xlab("") +
scale_x_date(date_breaks="1 month", date_labels="%b") +
#ylim(0,6) +
ylab("Reff") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black'))
plot3<- ggplot() +
geom_line(data=incidence_log,aes(x=date,y=cumulative_incidence_percentage),na.rm=TRUE) +
xlab("") +
scale_x_date(date_breaks="1 month", date_labels="%b") +
ylab("cumulative cases % whole pop") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black'))
grid.arrange(plot1, plot2, plot3, layout_matrix = lay)
}
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", echo=TRUE)
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", encoding = 'UTF-8', echo=TRUE)
