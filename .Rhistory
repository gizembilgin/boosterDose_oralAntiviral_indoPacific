if (vax_strategy_vaccine_type == "Johnson & Johnson" & vax_dose_strategy > 1){stop('We dont currently have an estimate of VE for 2 J&J')}
if (vax_strategy_start_date <= max(vaccination_history_TRUE$date)){
stop ('Your hypothetical vaccine campaign start date needs to be in the future!')
}
# if (vax_strategy_start_date <= date_start){
#   stop ('Your hypothetical vaccine campaign start date needs to be after the start date (unless you want to do more coding)')
# }
if (!(vax_strategy_vaccine_type %in% c("Moderna","Pfizer","AstraZeneca","Johnson & Johnson","Sinopharm","Sinovac"))){
stop('pick a valid vaccine type, or check your spelling!')
}
if (vax_delivery_group != "universal" & num_risk_groups == 1){
warning("You need a risk group to have a risk strategy! We have overwritten vax_delivery_group = 'universal'")
vax_delivery_group = 'universal'
}
### IMPORTS
prioritisation_csv <- read.csv("1_inputs/prioritisation.csv",header=TRUE)
if (vax_delivery_group %in% c('universal','general_public')){ this_risk_group = 'general_public'
} else if (vax_delivery_group == 'at_risk'){ this_risk_group = risk_group_name}
#_______________________________________________________________________________
#####(1/?) Calculate the eligible population ###################################
if (vax_delivery_group == 'universal'){
eligible_pop = data.frame(pop_setting)
colnames(eligible_pop) = c('age_group','eligible_individuals')
} else if (vax_delivery_group == 'at_risk'){
eligible_pop = pop_risk_group_dn[pop_risk_group_dn == risk_group_name,] %>% select(age_group,pop)
colnames(eligible_pop) = c('age_group','eligible_individuals')
} else if (vax_delivery_group == 'general_public'){
eligible_pop = pop_risk_group_dn[pop_risk_group_dn == 'general_public',] %>% select(age_group,pop)
colnames(eligible_pop) = c('age_group','eligible_individuals')
}
#make long by dose
workshop = data.frame()
for (i in 1:num_vax_doses){
this_dose = as.data.frame(eligible_pop) %>% mutate(dose = i)
workshop = rbind(workshop,this_dose)
}
eligible_pop= workshop
#remove already vaccinated individuals
existing_coverage = crossing(dose = c(1:num_vax_doses),
age_group = age_group_labels,
cov_to_date = 0)
for (d in 1:num_vax_doses){
for (i in 1:num_age_groups){
#need to sum across vaccine_coverage (as this is vaccination_history_POP split across age groups)
existing_coverage$cov_to_date[existing_coverage$dose == d &
existing_coverage$age_group == age_group_labels[i]] =
sum(vaccine_coverage_end_history$coverage_this_date[vaccine_coverage_end_history$risk_group == this_risk_group &
vaccine_coverage_end_history$dose == d &
vaccine_coverage_end_history$age_group == age_group_labels[i]])
}
}
#COMEBACK RISK - existing coverage is in % age group, may need to make risk specific
## CHECK - aligns!
# workshop<- eligible_pop %>% left_join(existing_coverage) %>%
#   mutate(eligible_individuals = round(eligible_individuals *(1-cov_to_date))) %>%
#   select(age_group,dose,eligible_individuals)
# 1-aggregate(workshop$eligible_individuals, by=list(workshop$dose), FUN=sum)$x/sum(pop)
# workshop <- vaccination_history_POP[vaccination_history_POP$date == as.Date('2022-02-22'),]
# aggregate(workshop$coverage_this_date, by=list(workshop$dose), FUN=sum)
#now remove vaccinated, and vaccine hesistant
unreachable = 1-vax_strategy_max_expected_cov
#COMEBACK RISK - vaccine hesitancy may differ in the at risk group
eligible_pop <- eligible_pop %>% left_join(existing_coverage) %>%
mutate(eligible_individuals = round(eligible_individuals *(1-(cov_to_date+unreachable)))) %>%
select(age_group,dose,eligible_individuals)
#NOTE: some with dose 2 > dose 1
#Assume covered by existing vaccine supply and/or never likely to get second dose?
# if ("Johnson & Johnson" %in% vax_type_list ){
#   workshop_JJ =  vaccination_history_POP$coverage_this_date[vaccination_history_POP$date == max(vaccination_history_POP$date) &
#                                                                 vaccination_history_POP$vaccine_type == "Johnson & Johnson"]
# } else {workshop_JJ=0 }
# diff_dose_one_two  = sum(eligible_pop$eligible_individuals[eligible_pop$dose == 2] - eligible_pop$eligible_individuals[eligible_pop$dose == 1])
#
# diff_dose_one_two - workshop_JJ/100* sum(pop)
# 100*diff_dose_one_two/sum(pop) - workshop_JJ
# COMEBACK / ASSUMPTIOn: people with dose 1 will either be addressed by existing schema, or never followed up
eligible_pop$eligible_individuals[eligible_pop$dose == 2] = eligible_pop$eligible_individuals[eligible_pop$dose == 1]
#_______________________________________________________________________________
#####(2/?) Place priority # on age group by strategy ############################
if (vax_age_strategy %in% unique(prioritisation_csv$strategy)) {
elected_strategy = prioritisation_csv[prioritisation_csv$strategy == vax_age_strategy,c('age_group','priority')]
eligible_pop <- eligible_pop %>% left_join(elected_strategy)
} else if (vax_age_strategy == "manual_overwrite"){
eligible_pop <- eligible_pop %>%
mutate(priority= case_when(
age_group == '70 to 100' ~ 6,
age_group == '60 to 69' ~ 5,
age_group == '45 to 59' ~ 4,
age_group == '30 to 44' ~ 3,
age_group == '18 to 29' ~ 2,
age_group == '5 to 17' ~ 1,
age_group == '0 to 4' ~ 99
))
}
#Note: 99 used as a 'never' indicator
#_______________________________________________________________________________
#####(3/?)  Distribute doses by priority #######################################
doses_to_deliver = vax_strategy_num_doses
priority_num = 1
eligible_pop <- eligible_pop %>% mutate(doses_delivered = 0)
n=length(unique(eligible_pop$priority))
highest_priority = sort(unique(eligible_pop$priority),partial=n-1)[n-1] #highest valid priority
while (doses_to_deliver>0 & priority_num <= (highest_priority)){
priority_group = eligible_pop[eligible_pop$priority == priority_num,]
workshop = doses_to_deliver/vax_dose_strategy - sum(priority_group$eligible_individuals[priority_group$dose == 1]) #check enough for all priority groups
if (workshop < 0){
prop_to_deliver = doses_to_deliver/vax_dose_strategy / sum(priority_group$eligible_individuals[priority_group$dose == 1])
priority_group$doses_delivered[priority_group$dose == vax_dose_strategy] = prop_to_deliver * priority_group$eligible_individuals[priority_group$dose == vax_dose_strategy]
if (vax_dose_strategy == 2){priority_group$doses_delivered[priority_group$dose == 1] = prop_to_deliver * priority_group$eligible_individuals[priority_group$dose == 1] }
doses_to_deliver = 0
} else if (workshop>0){
priority_group$doses_delivered[priority_group$dose == vax_dose_strategy] =  priority_group$eligible_individuals[priority_group$dose == vax_dose_strategy]
doses_to_deliver = doses_to_deliver - sum(priority_group$eligible_individuals[priority_group$dose == vax_dose_strategy])
if (vax_dose_strategy == 2){
workshop2 = doses_to_deliver- sum(priority_group$eligible_individuals[priority_group$dose == 1])
if(workshop2 < 0){
prop_to_deliver = doses_to_deliver / sum(priority_group$eligible_individuals[priority_group$dose == 1])
priority_group$doses_delivered[priority_group$dose == 1] = doses_to_deliver
doses_to_deliver = 0
} else{
priority_group$doses_delivered[priority_group$dose == 1] = priority_group$eligible_individuals[priority_group$dose == 1]
doses_to_deliver = doses_to_deliver - sum(priority_group$eligible_individuals[priority_group$dose == 1])
}
}
}
eligible_pop$doses_delivered[eligible_pop$priority == priority_num] = priority_group$doses_delivered
priority_num = priority_num + 1
}
#_______________________________________________________________________________
#####(4/?) Distribute between days #############################################
# we should use:
# (1) vax_strategy_num_doses - doses to deliver
# (2) vax_strategy_roll_out_speed - max doses delivered per day
# (3) vax_strategy_start_date - first day of doses delivered
VA =  eligible_pop %>% mutate(doses_left = doses_delivered)
priority_num = 1
priority_group  = as.character(unique(VA$age_group[VA$priority == priority_num]))
if (vax_dose_strategy == 1){
ceiling = min(sum(eligible_pop$doses_delivered),vax_strategy_num_doses) #max delivery (either limited by eligible individuals, or available doses!)
timeframe = ceiling/vax_strategy_roll_out_speed
daily_per_dose = vax_strategy_roll_out_speed
} else if (vax_dose_strategy == 2){
#COMEBACK - do we need a ceiling here too?
if(vax_strategy_num_doses/(vax_strategy_roll_out_speed*2)<vax_strategy_vaccine_interval){
timeframe = vax_strategy_num_doses/(vax_strategy_roll_out_speed*2)
daily_per_dose = vax_strategy_roll_out_speed
} else{
timeframe = vax_strategy_num_doses/(vax_strategy_roll_out_speed)
daily_per_dose = vax_strategy_roll_out_speed/2
}
}
timeframe = round(timeframe)
if (is.na(restriction_date) == FALSE){
timeframe = as.numeric(restriction_date - vax_strategy_start_date) + 1
}
length_track = timeframe
if (vax_dose_strategy == 2){length_track=length_track+vax_strategy_vaccine_interval}
vax_delivery_outline <- crossing(day = c(1:length_track),
dose = c(1:num_vax_doses),
age_group = age_group_labels,
doses_delivered = c(0))
#for (day in 1:229){
for (day in 1:timeframe){
avaliable = daily_per_dose
#ensuring that we don't overshoot available doses
if (day == timeframe){avaliable = vax_strategy_num_doses/vax_dose_strategy-(timeframe-1)*daily_per_dose}
if (avaliable > sum(VA$doses_left)){avaliable = sum(VA$doses_left)}
while(avaliable>0 & priority_num <= highest_priority){
if(sum(VA$doses_left[VA$priority == priority_num])>0){
#i.e., while we still have doses to deliver in this priority group
if(0 %in% VA$doses_left[VA$priority == priority_num & VA$dose == 1]){
age_complete = VA$age_group[VA$doses_left == 0 & VA$priority == priority_num & VA$dose == 1]
VA$priority[VA$age_group %in% age_complete] = VA$priority[VA$age_group %in% age_complete] + 100
priority_group = as.character(unique(VA$age_group[VA$priority == priority_num]))
} #FIX - when one age group in the priority group runs out first
#ISSUE HERE
workshop_doses = min(sum(VA$doses_left[VA$priority == priority_num & VA$dose == 1]),
daily_per_dose)
#either deliver max capacity or number left in this group, whichever is fewer
leftover=0
for (i in length(priority_group):1){
workshop_age = priority_group[i]
workshop_prop = sum(VA$doses_left[VA$age_group == workshop_age])/sum(VA$doses_left[VA$priority == priority_num])
workshop_calc = workshop_doses * workshop_prop + leftover
if (workshop_calc > VA$doses_left[VA$age_group == workshop_age & VA$dose == 1]){
leftover = abs(workshop_calc - VA$doses_left[VA$age_group == workshop_age & VA$dose == 1])
workshop_calc = VA$doses_left[VA$age_group == workshop_age & VA$dose == 1]
} else{
leftover = 0
}
vax_delivery_outline$doses_delivered[vax_delivery_outline$day == day &
vax_delivery_outline$dose == 1 &
vax_delivery_outline$age_group == workshop_age] = workshop_calc
VA$doses_left[VA$age_group == workshop_age & VA$dose == 1] = VA$doses_left[VA$age_group == workshop_age & VA$dose == 1] - workshop_calc
if (vax_dose_strategy == 2){
vax_delivery_outline$doses_delivered[vax_delivery_outline$day == day + vax_strategy_vaccine_interval &
vax_delivery_outline$dose == 2 &
vax_delivery_outline$age_group == workshop_age] = workshop_calc
VA$doses_left[VA$age_group == workshop_age & VA$dose == 2] = VA$doses_left[VA$age_group == workshop_age & VA$dose == 2] - workshop_calc
}
}
avaliable = avaliable - workshop_doses
} else if (sum(VA$doses_left[VA$priority == priority_num])==0){
priority_num = priority_num+1
priority_group = as.character(unique(VA$age_group[VA$priority == priority_num]))
} else{
stop('negative doses left, reconsider!')
}
} #<end while loop>
}
### formating vax_delivery_outline to align with vaccination_history_TRUE
vax_delivery_outline$date = vax_strategy_start_date + (vax_delivery_outline$day-1)
vax_delivery_outline$vaccine_type = vax_strategy_vaccine_type
if (vax_strategy_vaccine_type %in% c("Moderna","Pfizer")){
vax_delivery_outline$vaccine_mode = 'mRNA'
} else if (vax_strategy_vaccine_type %in% c("AstraZeneca","Johnson & Johnson","Sinopharm","Sinovac")){
vax_delivery_outline$vaccine_mode = 'viral'
}
vax_delivery_outline$coverage_this_date = NA #shouldn't be used anyway
names(vax_delivery_outline)[names(vax_delivery_outline) == 'doses_delivered'] <-'doses_delivered_this_date'
vax_delivery_outline = vax_delivery_outline %>%
select(date,vaccine_type,vaccine_mode,dose,coverage_this_date,doses_delivered_this_date,age_group)
#CHECK - aggregate(vax_delivery_outline$doses_delivered_this_date,by=list(vax_delivery_outline$age_group),FUN=sum) - aligns with eligible_pop
### adding to end of vaccination_history_TRUE
#do we need zero rows?
if(vax_delivery_group != 'universal'){
return(vax_delivery_outline)
} #HERE return as vaccination_history if 'universal', but as extra lines + timeframe if at risk
vaccination_history_MODF = rbind(vaccination_history_TRUE,vax_delivery_outline)
vax_delivery_group = 'universal'
### WARNINGS
if (vax_strategy_vaccine_type == "Johnson & Johnson" & vax_dose_strategy > 1){stop('We dont currently have an estimate of VE for 2 J&J')}
if (vax_strategy_start_date <= max(vaccination_history_TRUE$date)){
stop ('Your hypothetical vaccine campaign start date needs to be in the future!')
}
# if (vax_strategy_start_date <= date_start){
#   stop ('Your hypothetical vaccine campaign start date needs to be after the start date (unless you want to do more coding)')
# }
if (!(vax_strategy_vaccine_type %in% c("Moderna","Pfizer","AstraZeneca","Johnson & Johnson","Sinopharm","Sinovac"))){
stop('pick a valid vaccine type, or check your spelling!')
}
if (vax_delivery_group != "universal" & num_risk_groups == 1){
warning("You need a risk group to have a risk strategy! We have overwritten vax_delivery_group = 'universal'")
vax_delivery_group = 'universal'
}
### IMPORTS
prioritisation_csv <- read.csv("1_inputs/prioritisation.csv",header=TRUE)
if (vax_delivery_group %in% c('universal','general_public')){ this_risk_group = 'general_public'
} else if (vax_delivery_group == 'at_risk'){ this_risk_group = risk_group_name}
#_______________________________________________________________________________
#####(1/?) Calculate the eligible population ###################################
if (vax_delivery_group == 'universal'){
eligible_pop = data.frame(pop_setting)
colnames(eligible_pop) = c('age_group','eligible_individuals')
} else if (vax_delivery_group == 'at_risk'){
eligible_pop = pop_risk_group_dn[pop_risk_group_dn == risk_group_name,] %>% select(age_group,pop)
colnames(eligible_pop) = c('age_group','eligible_individuals')
} else if (vax_delivery_group == 'general_public'){
eligible_pop = pop_risk_group_dn[pop_risk_group_dn == 'general_public',] %>% select(age_group,pop)
colnames(eligible_pop) = c('age_group','eligible_individuals')
}
#make long by dose
workshop = data.frame()
for (i in 1:num_vax_doses){
this_dose = as.data.frame(eligible_pop) %>% mutate(dose = i)
workshop = rbind(workshop,this_dose)
}
eligible_pop= workshop
#remove already vaccinated individuals
existing_coverage = crossing(dose = c(1:num_vax_doses),
age_group = age_group_labels,
cov_to_date = 0)
for (d in 1:num_vax_doses){
for (i in 1:num_age_groups){
#need to sum across vaccine_coverage (as this is vaccination_history_POP split across age groups)
existing_coverage$cov_to_date[existing_coverage$dose == d &
existing_coverage$age_group == age_group_labels[i]] =
sum(vaccine_coverage_end_history$coverage_this_date[vaccine_coverage_end_history$risk_group == this_risk_group &
vaccine_coverage_end_history$dose == d &
vaccine_coverage_end_history$age_group == age_group_labels[i]])
}
}
#COMEBACK RISK - existing coverage is in % age group, may need to make risk specific
## CHECK - aligns!
# workshop<- eligible_pop %>% left_join(existing_coverage) %>%
#   mutate(eligible_individuals = round(eligible_individuals *(1-cov_to_date))) %>%
#   select(age_group,dose,eligible_individuals)
# 1-aggregate(workshop$eligible_individuals, by=list(workshop$dose), FUN=sum)$x/sum(pop)
# workshop <- vaccination_history_POP[vaccination_history_POP$date == as.Date('2022-02-22'),]
# aggregate(workshop$coverage_this_date, by=list(workshop$dose), FUN=sum)
#now remove vaccinated, and vaccine hesistant
unreachable = 1-vax_strategy_max_expected_cov
#COMEBACK RISK - vaccine hesitancy may differ in the at risk group
eligible_pop <- eligible_pop %>% left_join(existing_coverage) %>%
mutate(eligible_individuals = round(eligible_individuals *(1-(cov_to_date+unreachable)))) %>%
select(age_group,dose,eligible_individuals)
#NOTE: some with dose 2 > dose 1
#Assume covered by existing vaccine supply and/or never likely to get second dose?
# if ("Johnson & Johnson" %in% vax_type_list ){
#   workshop_JJ =  vaccination_history_POP$coverage_this_date[vaccination_history_POP$date == max(vaccination_history_POP$date) &
#                                                                 vaccination_history_POP$vaccine_type == "Johnson & Johnson"]
# } else {workshop_JJ=0 }
# diff_dose_one_two  = sum(eligible_pop$eligible_individuals[eligible_pop$dose == 2] - eligible_pop$eligible_individuals[eligible_pop$dose == 1])
#
# diff_dose_one_two - workshop_JJ/100* sum(pop)
# 100*diff_dose_one_two/sum(pop) - workshop_JJ
# COMEBACK / ASSUMPTIOn: people with dose 1 will either be addressed by existing schema, or never followed up
eligible_pop$eligible_individuals[eligible_pop$dose == 2] = eligible_pop$eligible_individuals[eligible_pop$dose == 1]
#_______________________________________________________________________________
#####(2/?) Place priority # on age group by strategy ############################
if (vax_age_strategy %in% unique(prioritisation_csv$strategy)) {
elected_strategy = prioritisation_csv[prioritisation_csv$strategy == vax_age_strategy,c('age_group','priority')]
eligible_pop <- eligible_pop %>% left_join(elected_strategy)
} else if (vax_age_strategy == "manual_overwrite"){
eligible_pop <- eligible_pop %>%
mutate(priority= case_when(
age_group == '70 to 100' ~ 6,
age_group == '60 to 69' ~ 5,
age_group == '45 to 59' ~ 4,
age_group == '30 to 44' ~ 3,
age_group == '18 to 29' ~ 2,
age_group == '5 to 17' ~ 1,
age_group == '0 to 4' ~ 99
))
}
#Note: 99 used as a 'never' indicator
#_______________________________________________________________________________
#####(3/?)  Distribute doses by priority #######################################
doses_to_deliver = vax_strategy_num_doses
priority_num = 1
eligible_pop <- eligible_pop %>% mutate(doses_delivered = 0)
n=length(unique(eligible_pop$priority))
highest_priority = sort(unique(eligible_pop$priority),partial=n-1)[n-1] #highest valid priority
while (doses_to_deliver>0 & priority_num <= (highest_priority)){
priority_group = eligible_pop[eligible_pop$priority == priority_num,]
workshop = doses_to_deliver/vax_dose_strategy - sum(priority_group$eligible_individuals[priority_group$dose == 1]) #check enough for all priority groups
if (workshop < 0){
prop_to_deliver = doses_to_deliver/vax_dose_strategy / sum(priority_group$eligible_individuals[priority_group$dose == 1])
priority_group$doses_delivered[priority_group$dose == vax_dose_strategy] = prop_to_deliver * priority_group$eligible_individuals[priority_group$dose == vax_dose_strategy]
if (vax_dose_strategy == 2){priority_group$doses_delivered[priority_group$dose == 1] = prop_to_deliver * priority_group$eligible_individuals[priority_group$dose == 1] }
doses_to_deliver = 0
} else if (workshop>0){
priority_group$doses_delivered[priority_group$dose == vax_dose_strategy] =  priority_group$eligible_individuals[priority_group$dose == vax_dose_strategy]
doses_to_deliver = doses_to_deliver - sum(priority_group$eligible_individuals[priority_group$dose == vax_dose_strategy])
if (vax_dose_strategy == 2){
workshop2 = doses_to_deliver- sum(priority_group$eligible_individuals[priority_group$dose == 1])
if(workshop2 < 0){
prop_to_deliver = doses_to_deliver / sum(priority_group$eligible_individuals[priority_group$dose == 1])
priority_group$doses_delivered[priority_group$dose == 1] = doses_to_deliver
doses_to_deliver = 0
} else{
priority_group$doses_delivered[priority_group$dose == 1] = priority_group$eligible_individuals[priority_group$dose == 1]
doses_to_deliver = doses_to_deliver - sum(priority_group$eligible_individuals[priority_group$dose == 1])
}
}
}
eligible_pop$doses_delivered[eligible_pop$priority == priority_num] = priority_group$doses_delivered
priority_num = priority_num + 1
}
#_______________________________________________________________________________
#####(4/?) Distribute between days #############################################
# we should use:
# (1) vax_strategy_num_doses - doses to deliver
# (2) vax_strategy_roll_out_speed - max doses delivered per day
# (3) vax_strategy_start_date - first day of doses delivered
VA =  eligible_pop %>% mutate(doses_left = doses_delivered)
priority_num = 1
priority_group  = as.character(unique(VA$age_group[VA$priority == priority_num]))
if (vax_dose_strategy == 1){
ceiling = min(sum(eligible_pop$doses_delivered),vax_strategy_num_doses) #max delivery (either limited by eligible individuals, or available doses!)
timeframe = ceiling/vax_strategy_roll_out_speed
daily_per_dose = vax_strategy_roll_out_speed
} else if (vax_dose_strategy == 2){
#COMEBACK - do we need a ceiling here too?
if(vax_strategy_num_doses/(vax_strategy_roll_out_speed*2)<vax_strategy_vaccine_interval){
timeframe = vax_strategy_num_doses/(vax_strategy_roll_out_speed*2)
daily_per_dose = vax_strategy_roll_out_speed
} else{
timeframe = vax_strategy_num_doses/(vax_strategy_roll_out_speed)
daily_per_dose = vax_strategy_roll_out_speed/2
}
}
timeframe = round(timeframe)
if (is.na(restriction_date) == FALSE){
timeframe = as.numeric(restriction_date - vax_strategy_start_date) + 1
}
length_track = timeframe
if (vax_dose_strategy == 2){length_track=length_track+vax_strategy_vaccine_interval}
vax_delivery_outline <- crossing(day = c(1:length_track),
dose = c(1:num_vax_doses),
age_group = age_group_labels,
doses_delivered = c(0))
#for (day in 1:229){
for (day in 1:timeframe){
avaliable = daily_per_dose
#ensuring that we don't overshoot available doses
if (day == timeframe){avaliable = vax_strategy_num_doses/vax_dose_strategy-(timeframe-1)*daily_per_dose}
if (avaliable > sum(VA$doses_left)){avaliable = sum(VA$doses_left)}
while(avaliable>0 & priority_num <= highest_priority){
if(sum(VA$doses_left[VA$priority == priority_num])>0){
#i.e., while we still have doses to deliver in this priority group
if(0 %in% VA$doses_left[VA$priority == priority_num & VA$dose == 1]){
age_complete = VA$age_group[VA$doses_left == 0 & VA$priority == priority_num & VA$dose == 1]
VA$priority[VA$age_group %in% age_complete] = VA$priority[VA$age_group %in% age_complete] + 100
priority_group = as.character(unique(VA$age_group[VA$priority == priority_num]))
} #FIX - when one age group in the priority group runs out first
#ISSUE HERE
workshop_doses = min(sum(VA$doses_left[VA$priority == priority_num & VA$dose == 1]),
daily_per_dose)
#either deliver max capacity or number left in this group, whichever is fewer
leftover=0
for (i in length(priority_group):1){
workshop_age = priority_group[i]
workshop_prop = sum(VA$doses_left[VA$age_group == workshop_age])/sum(VA$doses_left[VA$priority == priority_num])
workshop_calc = workshop_doses * workshop_prop + leftover
if (workshop_calc > VA$doses_left[VA$age_group == workshop_age & VA$dose == 1]){
leftover = abs(workshop_calc - VA$doses_left[VA$age_group == workshop_age & VA$dose == 1])
workshop_calc = VA$doses_left[VA$age_group == workshop_age & VA$dose == 1]
} else{
leftover = 0
}
vax_delivery_outline$doses_delivered[vax_delivery_outline$day == day &
vax_delivery_outline$dose == 1 &
vax_delivery_outline$age_group == workshop_age] = workshop_calc
VA$doses_left[VA$age_group == workshop_age & VA$dose == 1] = VA$doses_left[VA$age_group == workshop_age & VA$dose == 1] - workshop_calc
if (vax_dose_strategy == 2){
vax_delivery_outline$doses_delivered[vax_delivery_outline$day == day + vax_strategy_vaccine_interval &
vax_delivery_outline$dose == 2 &
vax_delivery_outline$age_group == workshop_age] = workshop_calc
VA$doses_left[VA$age_group == workshop_age & VA$dose == 2] = VA$doses_left[VA$age_group == workshop_age & VA$dose == 2] - workshop_calc
}
}
avaliable = avaliable - workshop_doses
} else if (sum(VA$doses_left[VA$priority == priority_num])==0){
priority_num = priority_num+1
priority_group = as.character(unique(VA$age_group[VA$priority == priority_num]))
} else{
stop('negative doses left, reconsider!')
}
} #<end while loop>
}
### formating vax_delivery_outline to align with vaccination_history_TRUE
vax_delivery_outline$date = vax_strategy_start_date + (vax_delivery_outline$day-1)
vax_delivery_outline$vaccine_type = vax_strategy_vaccine_type
if (vax_strategy_vaccine_type %in% c("Moderna","Pfizer")){
vax_delivery_outline$vaccine_mode = 'mRNA'
} else if (vax_strategy_vaccine_type %in% c("AstraZeneca","Johnson & Johnson","Sinopharm","Sinovac")){
vax_delivery_outline$vaccine_mode = 'viral'
}
vax_delivery_outline$coverage_this_date = NA #shouldn't be used anyway
names(vax_delivery_outline)[names(vax_delivery_outline) == 'doses_delivered'] <-'doses_delivered_this_date'
vax_delivery_outline = vax_delivery_outline %>%
select(date,vaccine_type,vaccine_mode,dose,coverage_this_date,doses_delivered_this_date,age_group)
#CHECK - aggregate(vax_delivery_outline$doses_delivered_this_date,by=list(vax_delivery_outline$age_group),FUN=sum) - aligns with eligible_pop
### adding to end of vaccination_history_TRUE
#do we need zero rows?
if(vax_delivery_group != 'universal'){
return(vax_delivery_outline)
} #HERE return as vaccination_history if 'universal', but as extra lines + timeframe if at risk
vaccination_history_MODF = rbind(vaccination_history_TRUE,vax_delivery_outline)
unique(vaccination_history_MODF$risk_group)
unique(vaccination_history_TRUE$risk_group)
unique(vax_delivery_outline$risk_group)
colnames(vax_delivery_outline)
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(function)_vax_strategies.R", echo=TRUE)
#(iii/iv) Add hypothetical campaign (if 'on') ____
if (vax_strategy_toggle == "on" & vax_risk_strategy_toggle == "off"){
vaccination_history_FINAL =
vax_strategy(vax_strategy_start_date        = vax_strategy_toggles$vax_strategy_start_date,
vax_strategy_num_doses         = vax_strategy_toggles$vax_strategy_num_doses,
vax_strategy_roll_out_speed    = vax_strategy_toggles$vax_strategy_roll_out_speed,
vax_age_strategy               = vax_strategy_toggles$vax_age_strategy,
vax_dose_strategy              = vax_strategy_toggles$vax_dose_strategy,
vax_strategy_vaccine_type      = vax_strategy_toggles$vax_strategy_vaccine_type,
vax_strategy_vaccine_interval  = vax_strategy_toggles$vax_strategy_vaccine_interval,
vax_strategy_max_expected_cov  = vax_strategy_toggles$vax_strategy_max_expected_cov
)
#recalculate!
num_vax_doses = D = length(unique(vaccination_history_FINAL$dose))  # dose 1, dose 2, COMEBACK no boosters yet in these settings
vax_type_list = sort(unique(vaccination_history_FINAL$vaccine_type))
num_vax_types = T = length(unique(vaccination_history_FINAL$vaccine_type))
num_vax_classes = num_vax_doses*num_vax_types + 1                 # + 1 for unvaccinated
num_total_classes = (num_disease_classes+1)*(num_age_groups*num_vax_classes) #+1 for incidence tracker
} else if (vax_strategy_toggle == "on" & vax_risk_strategy_toggle == "on"){
vaccination_history_FINAL =
apply_risk_strategy(vax_risk_strategy     = apply_risk_strategy_toggles$vax_risk_strategy,
vax_risk_proportion   = apply_risk_strategy_toggles$vax_risk_proportion,
vax_doses_general     = apply_risk_strategy_toggles$vax_doses_general,
vax_doses_risk        = apply_risk_strategy_toggles$vax_doses_risk  )
#recalculate!
num_vax_doses = D = length(unique(vaccination_history_FINAL$dose))  # dose 1, dose 2, COMEBACK no boosters yet in these settings
vax_type_list = sort(unique(vaccination_history_FINAL$vaccine_type))
num_vax_types = T = length(unique(vaccination_history_FINAL$vaccine_type))
num_vax_classes = num_vax_doses*num_vax_types + 1                 # + 1 for unvaccinated
num_total_classes = (num_disease_classes+1)*(num_age_groups*num_vax_classes) #+1 for incidence tracker
} else {
vaccination_history_FINAL = vaccination_history_TRUE
}
unique(vaccination_history_FINAL$risk_group)
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/(2)_inital_state.R", echo=TRUE)
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", echo=TRUE)
check$pop[1]
sum(pop)
round(check$pop[1]) !=sum(pop)
check$pop[1] !=sum(pop)
increments_number
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", echo=TRUE)
329.36/60
grid.arrange(save[[1]], save[[2]], save[[3]], layout_matrix = lay)
num_risk_groups
source("C:/Users/u6044061/Documents/PhD/Research/2_scarce_COVID_vaccine_supply/4_code/GitHub_vaxAllocation/CommandDeck.R", echo=TRUE)
num_risk_groups
